<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="/TRCKNG-SSTM/manifest.json">
  <link rel="apple-touch-icon" href="/TRCKNG-SSTM/icons/icon-192.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <title>TRCKNG SSTM</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: var(--app-bg, #000000);
      color: var(--app-text, #ffffff);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: calc(16px + env(safe-area-inset-top)) 16px calc(16px + env(safe-area-inset-bottom));
    }

    :root {
      --cell-diagonal-angle: 36.87deg;
      --cell-line-width: 1px;
    }
    .container {
      width: 100%;
      /* Adjust max-width below to tune desktop layout width */
      max-width: 1280px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    /* Controls group - no vertical gap between rows */
    .controls-group {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    /* ===== HEADER ===== */
    .header {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2px 16px 12px;
      gap: 8px;
    }
    
    .header-content {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      align-items: flex-start;
      width: 100%;
      gap: 16px;
    }

    .header-left,
    .header-right,
    .header-center {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .header-left {
      align-items: flex-start;
      text-align: left;
    }

    .header-center {
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .header-right {
      align-items: flex-start;
      text-align: left;
      justify-self: start;
    }

.header-week {
      font-family: "Roboto Condensed", -apple-system, sans-serif;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.02em;
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }
    .header-weekdate {
      font-size: 10px;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      line-height: 1.2;
      margin-top: 3px;
      font-weight: 400;
    }
    .header-week-percent {
      font-size: 10px;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.5);
      line-height: 1.2;
      margin-top: 2px;
      font-variant-numeric: tabular-nums;
      font-weight: 400;
    }
    .header-time {
      font-family: "Roboto Condensed", -apple-system, sans-serif;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.02em;
      font-variant-numeric: tabular-nums;
      line-height: 1;
    }
    .header-daydate {
      font-size: 10px;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      line-height: 1.2;
      margin-top: 3px;
      font-weight: 400;
    }
    .header-day-info {
      font-size: 10px;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.5);
      line-height: 1.2;
      margin-top: 2px;
      font-variant-numeric: tabular-nums;
      font-weight: 400;
    }

    /* ===== PINS ===== */
    .pins {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0;
      background: #000;
    }
    .pin {
      border: none;
      background: #000;
      color: rgba(255,255,255,0.5);
      padding: 8px 6px;
      cursor: pointer;
      font-size: 8px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      transition: all 100ms ease-out;
      -webkit-tap-highlight-color: transparent;
      min-height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pin:hover { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.8); }
    .pin.active { background: rgba(255,140,66,0.2); color: #ff8c42; }

    /* ===== CONTROLS ===== */
    .controls {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 0px;
      background: var(--app-bg, #000000);
      border-bottom: 1px solid var(--stroke-soft, rgba(255,255,255,0.15));
      }
    .controls-edit {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 0px;
      background: var(--app-bg, #000000);
      border-bottom: 1px solid var(--stroke-soft, rgba(255,255,255,0.15));
      }
    .btn-control-wide {
      grid-column: span 3;
    }
    .btn-control-edit {
      grid-column: span 2;
    }
    
    .btn-control-mini {
      grid-column: span 1;
      border: 1px solid var(--stroke-soft, rgba(255,255,255,0.15)) !important;
      }
.btn-control-pin {
      grid-column: span 1;
      border: 1px solid var(--stroke-strong, rgba(255,255,255,0.35));
      background: transparent;
      color: var(--app-text, #ffffff);
      }
    .btn-control {
      border: none;
      background: transparent;
      color: var(--app-text, #ffffff);
      border: 1px solid var(--stroke-soft, rgba(255,255,255,0.15));
      padding: 8px 6px;
      cursor: pointer;
      font-size: 8px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      transition: all 100ms ease-out;
      -webkit-tap-highlight-color: transparent;
      min-height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }
    .btn-control:hover { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.9); }
    .btn-control:active { background: rgba(255,255,255,0.12); }
    .btn-control.active { background: rgba(255,79,106,0.3); color: #ff4f6a; }

    /* ===== HABITS GRID ===== */
    /* HABITS GRID FRAME SETUP:
       - border: frame around the full 3x3 grid
       - gap: spacing between cells
       - background: color of the lines between cells
    */
    .buttons-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0;
      background: #000;
      border: none;
    }

    .btn-habit {
      border: none;
      background: var(--btn-bg, #000);
      color: var(--btn-text, #fff);
      padding: 8px;
      cursor: pointer;
      font-size: 13px;
      letter-spacing: 0.06em;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: all 100ms ease-out;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      position: relative;
      overflow: hidden;
      -webkit-user-select: none;
      user-select: none;
      aspect-ratio: 4 / 3;
    }

    /* INACTIVE CELLS - different patterns per pin */
    .btn-habit.inactive {
      background: #000;
      cursor: default;
      pointer-events: none;
    }
    
    /* PIN 01 - diagonal cross (45deg) */
    [data-pin="0"] .btn-habit.inactive::after {
      content: '';
      position: absolute;
      inset: 0;
      background:
        linear-gradient(var(--cell-diagonal-angle),
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        ),
        linear-gradient(calc(180deg - var(--cell-diagonal-angle)),
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        );
      background-repeat: no-repeat;
      background-size: 100% 100%;
      pointer-events: none;
    }


    /* PIN 02 - grid (0deg/90deg) */

    [data-pin="1"] .btn-habit.inactive::after {
      content: '';
      position: absolute;
      inset: 0;
      background:
        linear-gradient(0deg,
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        ),
        linear-gradient(90deg,
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        );
      background-repeat: no-repeat;
      background-size: 100% 100%;
      pointer-events: none;
    }

    /* PIN 03 - hybrid (left diagonal + right grid) */

    [data-pin="2"] .btn-habit.inactive::after {
      content: '';
      position: absolute;
      inset: 0;
      background:
        linear-gradient(var(--cell-diagonal-angle),
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        ),
        linear-gradient(0deg,
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        ),
        linear-gradient(90deg,
          transparent calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% - var(--cell-line-width)),
          rgba(80,80,80,1) calc(50% + var(--cell-line-width)),
          transparent calc(50% + var(--cell-line-width))
        );
      background-repeat: no-repeat;
      background-size: 100% 100%;
      pointer-events: none;
    }



    /* Cell content structure */
    .btn-status {
      display: block;
      font-size: 10px;
      line-height: 1.2;
      margin-bottom: 3px;
      text-transform: lowercase;
      letter-spacing: 0.16em;
      opacity: 0.9;
    }
    .btn-status-countdown {
      text-transform: lowercase;
      opacity: 0.7;
    }
    .btn-status-timer {
      text-transform: lowercase;
      opacity: 0.7;
    }


    .btn-label { 
      font-size: 11px; 
      font-weight: 400; 
      opacity: 0.7;
      order: 2;
    }
    .btn-value { 
      font-family: "Roboto Condensed", -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: clamp(22px, 9vw, 36px);
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      line-height: 1;
      order: 3;
      letter-spacing: -0.02em;
      word-spacing: 0;
      font-feature-settings: "tnum" 1;
    }

    /* Countdown digits: stroke with black fill */
    .btn-habit[data-type="countdown"] .btn-value {
      color: #000000;
      -webkit-text-stroke: 1px var(--btn-color, #ffffff);
      text-stroke: 1px var(--btn-color, #ffffff);
    }

    .btn-habit[data-type="countdown"] .btn-value .btn-value-suffix {
      color: var(--btn-color, #ffffff);
      -webkit-text-stroke: 0;
      text-stroke: 0;
    }

    /* Small suffix letters (s, m) - 5x smaller */
    .btn-value-suffix {
      font-size: 0.5em;
      opacity: 0.6;
      margin-left: 0.1em;
    }
    .btn-breakdown {
      font-size: 9px;
      opacity: 0.5;
      letter-spacing: 0.06em;
      order: 4;
      min-height: 14px;
    }
    
    /* Responsive font tuning: phones a bit smaller, desktops a bit larger */
    @media (max-width: 600px) {
      .btn-label { font-size: 9px; }
      .btn-value { font-size: clamp(18px, 8vw, 30px); }
      .btn-breakdown { font-size: 9px; }
    }
    @media (min-width: 1200px) {
      .btn-label { font-size: 13px; }
      .btn-value { font-size: clamp(26px, 10vw, 44px); }
      .btn-breakdown { font-size: 11px; }
    }


    /* Running state with animated border */
    
    /* Running states base */
    .btn-habit.running {
      position: relative;
    }

    /* Duration types - colored border and background pulse */
    .btn-habit[data-type="duration_sec"].running,
    .btn-habit[data-type="duration_min"].running,
    .btn-habit[data-type="duration_sec_count"].running {
      border: 3px solid rgba(255, 255, 255, 0.1);
      background: color-mix(in srgb, var(--btn-color, #35f2a3) 15%, transparent);
      box-shadow: inset 0 0 0 3px var(--btn-color, #35f2a3);
      animation: borderPulse 2s ease-in-out infinite;
    }

    @keyframes borderPulse {
      0%, 100% {
        box-shadow: inset 0 0 0 3px var(--btn-color, #35f2a3);
      }
      50% {
        box-shadow: inset 0 0 0 3px color-mix(in srgb, var(--btn-color, #35f2a3) 50%, transparent);
      }
    }

    /* TIMER - top edge progress bar, black background, pulsing value */
    .btn-habit[data-type="timer"].running {
      border: 2px solid rgba(255, 255, 255, 0.35);
      background: #000;
    }

    .btn-habit[data-type="timer"].running::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 70%;
      height: 2px;
      background: var(--btn-color, #35f2a3);
      pointer-events: none;
      z-index: 2;
      animation: timerScan 60s linear infinite;
    }

    @keyframes timerScan {
      0% {
        left: -3px;
        right: 60%;
      }
      50% {
        left: 60%;
        right: -3px;
      }
      100% {
        left: -3px;
        right: 60%;
      }
    }

    /* COUNTDOWN - perimeter snake over one-minute cycle */
    .btn-habit[data-type="countdown"].running {
      border: none;
      background: #000;
    }

    .btn-habit[data-type="countdown"].running::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      width: 160%;
      height: 2px;
      background: var(--btn-color, #ffffff);
      pointer-events: none;
      z-index: 0;
      transform-origin: center center;
      transform: translate(-50%, -50%) rotate(var(--progress-angle, 0deg));
      opacity: 1;
      animation: none;
    }

    @keyframes countdownSnake {
      0% {
        transform: translateX(-50%) rotate(0deg);
      }
      100% {
        transform: translateX(-50%) rotate(-360deg);
      }
    }

/* Common z-index for content on top of effects */
    .btn-habit.running > * {
      position: relative;
      z-index: 1;
    }

    /* Value color for active cells */
    .btn-habit[data-type="duration_sec"].running .btn-value,
    .btn-habit[data-type="duration_min"].running .btn-value,
    .btn-habit[data-type="duration_sec_count"].running .btn-value,
    .btn-habit[data-type="timer"].running .btn-value {
      color: var(--btn-color, #35f2a3);
    }

    /* Timer text pulse */
    .btn-habit[data-type="timer"].running .btn-value {
      animation: timerTextPulse 16s ease-in-out infinite;
    }

    @keyframes timerTextPulse {
      0%, 100% {
        transform: scale(1);
        filter: brightness(1);
      }
      50% {
        transform: scale(1.08);
        filter: brightness(1.9);
      }
    }

    /* Countdown hourly flash */
    .btn-habit[data-type="countdown"].hour-ping {
      animation: countdownHourPing 0.8s ease-out;
    }

    @keyframes countdownHourPing {
      0% {
        box-shadow: 0 0 0 rgba(255,255,255,0);
      }
      40% {
        box-shadow: 0 0 40px rgba(255,255,255,0.9);
      }
      100% {
        box-shadow: 0 0 0 rgba(255,255,255,0);
      }
    }

    /* Countdown expired blinking value */
    .btn-habit[data-type="countdown"].pulsing .btn-value {
      animation: countdownExpired 1s steps(2, end) infinite;
    }

    @keyframes countdownExpired {
      0%, 100% { opacity: 1; }
      50%      { opacity: 0.4; }
    }

    /* Stronger tap feedback when value changes */
    .btn-habit.animating {
      animation: tapPress 1200ms cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    /* Countdown click feedback: text color flashes to accent, no background glow */
    .btn-habit[data-type="countdown"] .btn-label,
    .btn-habit[data-type="countdown"] .btn-status,
    .btn-habit[data-type="countdown"] .btn-value,
    .btn-habit[data-type="countdown"] .btn-breakdown {
      transition: color 5000ms ease-out;
    }

    .btn-habit[data-type="countdown"].animating .btn-label,
    .btn-habit[data-type="countdown"].animating .btn-status,
    .btn-habit[data-type="countdown"].animating .btn-value,
    .btn-habit[data-type="countdown"].animating .btn-breakdown {
      color: var(--btn-color, #ffffff);
      transition: none;
    }



    @keyframes tapPress {
      0% {
        transform: scale(1);
        filter: brightness(1);
      }
      30% {
        transform: scale(0.96);
        filter: brightness(1.6);
      }
      100% {
        transform: scale(1);
        filter: brightness(1.05);
      }
    }
/* Paused state */
    .btn-habit.paused {
      border: 2px solid var(--stroke-soft, rgba(255,255,255,0.15));
    }
    .btn-habit.paused .btn-value,
    .btn-habit.paused .btn-label,
    .btn-habit.paused .btn-status {
      opacity: 0.35;
    }

    /* Pulsing animation for expired countdown */
    .btn-habit.pulsing {
      animation: fastPulse 0.5s ease-in-out infinite;
    }
    @keyframes fastPulse {
      0%, 100% { 
        border-color: rgba(255,79,106,0.8);
        background: rgba(255,79,106,0.15);
      }
      50% { 
        border-color: rgba(255,79,106,0.3);
        background: rgba(255,79,106,0.05);
      }
    }

    /* Flash animation on click - bright and slow fade */
    .btn-habit::before {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--btn-color, transparent);
      opacity: 0;
      pointer-events: none;
      z-index: 0;
    }
    .btn-habit.animating::before {
      animation: flash 1500ms ease-out forwards;
    }
    @keyframes flash {
      0% { opacity: 1; }
      10% { opacity: 0.95; }
      30% { opacity: 0.7; }
      100% { opacity: 0; }
    }
    .btn-habit > * { position: relative; z-index: 2; }

    /* ===== STATS ===== */
    .stats {
      padding: 0;
      overflow-x: auto;
    }
    .stats-table {
      width: 100%;
      border-collapse: collapse;
      color: rgba(255,255,255,0.8);
    }
    
    .stats-table th, .stats-table td {
      padding: 10px 8px;
      text-align: center;
      border-right: 1px solid rgba(80,80,80,0.5);
      border-bottom: 1px solid rgba(80,80,80,0.5);
      background: transparent;
    }
    
    .stats-table th:last-child,
    .stats-table td:last-child {
      border-right: none;
    }
    
    .stats-table tbody tr:last-child td {
      border-bottom: none;
    }
    
    .stats-table th {
      font-size: 8px;
      font-weight: 400;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.5);
    }
    
    .stats-table td {
      font-family: "Roboto Condensed", -apple-system, sans-serif;
      font-size: 13px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      color: rgba(255,255,255,0.8);
    }
    
    .stats-table td:first-child, 
    .stats-table th:first-child {
      text-align: left;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 8px;
      font-weight: 400;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.5);
      cursor: pointer;
      transition: color 100ms ease-out;
    }

    /* Hover on week label only */
    .stats-table tbody td:first-child:hover {
      color: #ff8c42;
    }

    /* Hover effects - subtle */
    .stats-table tbody tr.row-highlight {
      background: rgba(255,140,66,0.03);
    }

    .stats-table th.col-highlight,
    .stats-table td.col-highlight {
      background: rgba(255,140,66,0.05) !important;
      color: #ff8c42 !important;
    }

    .stats-table th.cell-highlight,
    .stats-table td.cell-highlight {
      background: rgba(255,140,66,0.25) !important;
      color: #ff8c42 !important;
      font-weight: 500;
    }

    /* ===== MODALS ===== */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 100;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    .modal.visible { display: flex; }

    .modal-content {
      background: #000;
      border: 1px solid rgba(255,255,255,0.3);
      max-height: 80vh;
      overflow-y: auto;
      max-width: 500px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 0px solid rgba(255,255,255,0.3);
      padding: 16px 20px 12px;
    }
    .modal-title {
      font-size: 10px;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.5);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    .modal-header-right {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .modal-pin-btn {
      border: 1px solid rgba(255,255,255,0.4);
      background: #000;
      color: rgba(255,255,255,0.8);
      padding: 6px 10px;
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
    }
    .modal-pin-btn:hover {
      background: #fff;
      color: #000;
    }
    .modal-help-btn {
      border: 1px solid rgba(255,255,255,0.4);
      background: #000;
      color: rgba(255,255,255,0.7);
      padding: 5px 8px;
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
    }
    .modal-help-btn:hover {
      background: #fff;
      color: #000;
    }

    
    .modal-help-panel,
    .cell-help-panel {
      display: none;
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(0,0,0,0.9);
      font-size: 9px;
      line-height: 1.6;
      color: rgba(255,255,255,0.75);
    }
    .modal-help-panel.visible,
    .cell-help-panel.visible {
      display: block;
    }
.modal-buttons {
      display: flex;
      gap: 1px;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .modal-btn {
      flex: 1;
      border: none;
      background: #000;
      color: rgba(255,255,255,0.7);
      padding: 12px 8px;
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 100ms ease-out;
      -webkit-tap-highlight-color: transparent;
    }
    .modal-btn:hover { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.9); }
    .modal-btn.primary { background: #35f2a3; color: #000; }
    .modal-btn.primary:hover { background: #4df7b5; }

    /* Edit items grid */
    .edit-items-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.3);
    }
    .edit-item {
      background: #000;
      border: none;
      padding: 16px 8px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 80px;
      -webkit-tap-highlight-color: transparent;
    }
    .edit-item:hover { background: rgba(255,255,255,0.04); }
    .edit-item-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: rgba(255,255,255,0.4);
    }
    .edit-item-name {
      font-size: 12px;
      color: #fff;
      text-align: center;
      word-break: break-word;
    }

    /* Cell edit modal */
    .cell-edit-content {
      background: #000;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 20px;
      max-width: 520px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
    }
    
    .cell-edit-help-btn {
      position: absolute;
      top: 14px;
      right: 16px;
      border: 1px solid rgba(255,255,255,0.4);
      background: #000;
      color: rgba(255,255,255,0.7);
      padding: 4px 7px;
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
    }
    .cell-edit-help-btn:hover {
      background: #fff;
      color: #000;
    }

    .cell-edit-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .cell-edit-grid-2 {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 10px 12px;
    }

    .cell-edit-grid-3 {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px 12px;
    }

    .cell-edit-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .cell-edit-field-full {
      grid-column: 1 / -1;
    }

    .cell-edit-inline {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sound-test-btn {
      padding: 8px 10px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.4);
      background: #050607;
      color: #fff;
      font-size: 11px;
      font-family: inherit;
      cursor: pointer;
      flex-shrink: 0;
      transition: background 120ms, transform 120ms;
    }

    .sound-test-btn:active {
      transform: scale(0.96);
    }

    .sound-test-btn:hover {
      background: rgba(255,255,255,0.12);
    }

    @media (max-width: 480px) {
.cell-edit-content {
        max-width: 100%;
        padding: 16px;
      }
    }

    .cell-edit-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: rgba(255,255,255,0.5);
      text-align: center;
    }
    .cell-edit-input {
      background: #050607;
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 12px;
      font-size: 14px;
      font-family: inherit;
      text-align: center;
    }
    .cell-edit-input:focus {
      outline: none;
      border-color: #35f2a3;
    }

    .type-selector {
      display: flex;
      gap: 1px;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .type-btn {
      flex: 1;
      padding: 10px 4px;
      background: var(--panel-bg, #050607);
      border: none;
      color: var(--panel-text-muted, rgba(255,255,255,0.6));
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: all 100ms;
    }
    .type-btn:hover { background: rgba(255,255,255,0.08); }
    .type-btn.active { background: #35f2a3; color: #000; }

    .color-picker-wrap {
      margin-top: 8px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
      text-align: center;
    }
    .color-picker-label {
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 8px;
    }
    .color-picker {
      width: 100%;
      height: 40px;
      border: 1px solid rgba(255,255,255,0.2);
      background: #050607;
      cursor: pointer;
      padding: 2px;
    }
    .color-picker::-webkit-color-swatch-wrapper { padding: 0; }
    .color-picker::-webkit-color-swatch { border: none; }

    /* Info modal */
    .info-modal-content {
      background: #000;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 24px;
      max-width: 450px;
      width: 100%;
      max-height: 85vh;
      overflow-y: auto;
    }
    .info-header {
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .info-logo {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.08em;
      line-height: 1.2;
      margin-bottom: 8px;
    }
    .info-version {
      font-size: 11px;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.4);
      margin-bottom: 4px;
    }
    .info-author {
      font-size: 10px;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.3);
    }
    .info-author a {
      color: rgba(255,255,255,0.5);
      text-decoration: none;
    }
    .info-author a:hover { color: #ff8c42; }

    .info-section {
      margin-bottom: 16px;
    }
    .info-section-title {
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #ff8c42;
      margin-bottom: 6px;
    }
    .info-text {
      font-size: 12px;
      line-height: 1.6;
      color: rgba(255,255,255,0.75);
    }

    .info-footer {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .info-buttons {
      display: flex;
      gap: 8px;
    }
    .info-button {
      flex: 1;
      border: 1px solid rgba(255,255,255,0.3);
      background: #000;
      color: rgba(255,255,255,0.7);
      padding: 10px 12px;
      font-size: 9px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 100ms ease-out;
      text-decoration: none;
      text-align: center;
    }
    .info-button:hover { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.9); }

    /* Pulse animation for ? button */
    @keyframes btnPulse {
      0%, 100% { background: rgba(255,140,66,0.3); }
      50% { background: rgba(255,140,66,0.6); }
    }
    #btnInfo.pulse {
      animation: btnPulse 1.5s ease-in-out infinite;
      color: #ff8c42;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-content">
        <div class="header-left">
          <div class="header-time" id="headerTime">--:--:--</div>
          <div class="header-daydate" id="headerDayDate"></div>
          <div class="header-day-info" id="dayInfo">- --%</div>
        </div>
        <div class="header-center">
        </div>
        <div class="header-right">
          <div class="header-week" id="weekDisplay"></div>
          <div class="header-weekdate" id="dateDisplay"></div>
          <div class="header-week-percent" id="weekPercent">--%</div>
        </div>
      </div>
    </div>

    <div class="controls-group">
      <div class="pins">
        <button class="pin active" data-pin="0" id="pin0">PIN 01</button>
        <button class="pin" data-pin="1" id="pin1">PIN 02</button>
        <button class="pin" data-pin="2" id="pin2">PIN 03</button>
      </div>

      <div class="controls">
        <button class="btn-control" id="btnCopy">COPY</button>
        <button class="btn-control" id="btnCopyPrev">COPY PREV</button>
        <button class="btn-control" id="btnExport">EXPORT</button>
        <button class="btn-control" id="btnImport">IMPORT</button>
        <button class="btn-control" id="btnReset">RESET</button>
        <button class="btn-control" id="btnInfo">?</button>
      </div>

      <div class="controls-edit">
        <button class="btn-control btn-control-wide" id="btnDecrease">DECREASE</button>
        <button class="btn-control btn-control-edit" id="btnEdit">EDIT</button>
        <button class="btn-control btn-control-mini" id="btnTheme">THEME</button>
      </div>
    </div>

    <div class="buttons-grid" id="habitsGrid" data-pin="0"></div>

    <div class="stats" id="stats"></div>
  </div>

  <input type="file" id="fileInput" accept=".json,.txt" style="display:none">

  <!-- EDIT MODAL -->
  <div class="modal" id="editModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">TRCKNG SSTM · v0.99</div>
        <div class="modal-header-right">
          <button class="modal-pin-btn" id="btnEditPinName">PIN 01</button>
          <button class="modal-help-btn" id="btnEditHelp">?</button>
        </div>
      </div>
      <div class="modal-help-panel" id="editHelpPanel">
        <strong>EDIT mode · layout for current PIN</strong><br>
        You edit the 3×3 grid for the selected PIN. Each cell can track one thing: a counter, a timer, a duration, a countdown or money.
        <br><br>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 9px; color: rgba(255,255,255,0.75); line-height: 1.7; padding: 0 2px 4px;">
          <div>
            • Tap a cell to edit name, type, color, description<br>
            • Clear the name to deactivate the cell<br>
            • <strong style="color: rgba(255,255,255,0.9);">Counter:</strong> tap to +1, DECREASE to -1<br>
            • <strong style="color: rgba(255,255,255,0.9);">MM:SS:</strong> live stopwatch (minutes:seconds)
          </div>
          <div>
            • <strong style="color: rgba(255,255,255,0.9);">Min / Sec:</strong> live timers in minutes or seconds<br>
            • <strong style="color: rgba(255,255,255,0.9);">Timer:</strong> countdown with sound / vibration<br>
            • <strong style="color: rgba(255,255,255,0.9);">Countdown:</strong> target date & time in hours left<br>
            • <strong style="color: rgba(255,255,255,0.9);">Money:</strong> income / budget with custom step and currency
          </div>
        </div>
      </div>
      
      <div class="edit-items-grid" id="editItemsContainer"></div>
      <div class="modal-buttons">
        <button class="modal-btn" id="editModalClose">DONE</button>
      </div>
    </div>
  </div>

  <!-- CELL EDIT MODAL -->
  <div class="modal" id="cellEditModal">
    <div class="cell-edit-content">
      <button class="cell-edit-help-btn" id="btnCellEditHelp">?</button>
      <div class="cell-edit-label" id="cellEditLabel">CELL 01</div>
      <input type="text" class="cell-edit-input" id="cellEditInput" maxlength="20" autocomplete="off" placeholder="Cell name">
      <div class="cell-help-panel" id="cellEditHelpPanel">
        <strong>Cell editor</strong><br>
        Here you configure one cell of the grid.<br>
        • Name and optional description define the label under the number.<br>
        • Type switches behaviour: counter, MM:SS / MIN / SEC, timer, countdown, income or budget.<br>
        • Money types use step, currency symbol and optional budget start amount.<br>
        This is a draft help text – final version will describe all types and use cases in detail.
      </div>
      
      <div style="margin-top: 8px;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Type</div>
        <div class="type-selector">
          <button class="type-btn active" data-type="unit">Unit</button>
          <button class="type-btn" data-type="duration_sec">MM:SS</button>
          <button class="type-btn" data-type="duration_min">Min</button>
          <button class="type-btn" data-type="duration_sec_count">Sec</button>
        </div>
        <div class="type-selector" style="margin-top: 1px;">
          <button class="type-btn" data-type="value">Value</button>
          <button class="type-btn" data-type="math">Math</button>
          <button class="type-btn" data-type="timer">Timer</button>
          <button class="type-btn" data-type="countdown">Countdown</button>
        </div>
        <div class="type-selector" style="margin-top: 1px;">
          <button class="type-btn" data-type="money_income">Income</button>
          <button class="type-btn" data-type="money_budget">Budget</button>
        </div>
      </div>

      

            
      <!-- UNIT SETTINGS -->
      <div id="unitSettingsFields" class="cell-edit-section" style="display: none;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Unit</div>
        <div class="cell-edit-grid-2">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Step</div>
            <input type="number" class="cell-edit-input" id="unitStep" min="0" step="1" value="1" autocomplete="off">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Total across weeks</div>
            <label style="display:flex; align-items:center; gap:8px; padding: 10px 6px; background: rgba(255,255,255,0.04); border-radius: 10px;">
              <input type="checkbox" id="unitTotal" />
              <span style="opacity:0.75; font-size: 12px;">Sum all weeks</span>
            </label>
          </div>
        </div>
      </div>

      <!-- VALUE SETTINGS -->
      <div id="valueSettingsFields" class="cell-edit-section" style="display: none;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Value</div>
        <div class="cell-edit-grid-2">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Display</div>
            <select class="cell-edit-input" id="valueFormat">
              <option value="raw">Raw</option>
              <option value="int">Integer</option>
              <option value="2dp">2 decimals</option>
              <option value="3dp">3 decimals</option>
              <option value="time_mmss">Time MM:SS</option>
              <option value="time_m">Time minutes</option>
              <option value="time_h">Time hours</option>
              <option value="time_s">Time seconds</option>
            </select>
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Tap</div>
            <div style="opacity:0.75; font-size: 12px; padding: 10px 6px; background: rgba(255,255,255,0.04); border-radius: 10px;">
              opens numeric input
            </div>
          </div>
        </div>
      </div>

      <!-- MATH SETTINGS -->
      <div id="mathSettingsFields" class="cell-edit-section" style="display: none;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Math</div>
        <div class="cell-edit-grid-2">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Source A</div>
            <select class="cell-edit-input" id="mathSourceA"></select>
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Operation</div>
            <select class="cell-edit-input" id="mathOp">
              <option value="add">A + B</option>
              <option value="sub">A - B</option>
              <option value="mul">A × B</option>
              <option value="div">A ÷ B</option>
              <option value="min">min(A,B)</option>
              <option value="max">max(A,B)</option>
              <option value="pow2">A²</option>
              <option value="abs">abs(A)</option>
              <option value="round">round(A)</option>
              <option value="floor">floor(A)</option>
              <option value="ceil">ceil(A)</option>
              <option value="cos">cos(A)</option>
            </select>
          </div>
        </div>

        <div class="cell-edit-grid-2" style="margin-top: 8px;">
          <div class="cell-edit-field">
            <div class="cell-edit-label">B mode</div>
            <div class="type-selector">
              <button class="type-btn" id="mathBModeCell" data-math-bmode="cell">Cell</button>
              <button class="type-btn" id="mathBModeNumber" data-math-bmode="number">Number</button>
            </div>
          </div>
          <div class="cell-edit-field" id="mathBCellWrap">
            <div class="cell-edit-label">Source B</div>
            <select class="cell-edit-input" id="mathSourceB"></select>
          </div>
          <div class="cell-edit-field" id="mathBNumberWrap" style="display:none;">
            <div class="cell-edit-label">Number B</div>
            <input type="number" class="cell-edit-input" id="mathNumberB" value="1" step="0.1" autocomplete="off">
          </div>
        </div>

        <div class="cell-edit-grid-2" style="margin-top: 8px;">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Format</div>
            <select class="cell-edit-input" id="mathFormatFrom">
              <option value="a">Auto like A</option>
              <option value="b">Auto like B</option>
              <option value="raw">Raw number</option>
              <option value="int">Integer</option>
              <option value="2dp">2 decimals</option>
              <option value="3dp">3 decimals</option>
              <option value="time_mmss">Time MM:SS</option>
              <option value="time_m">Time minutes</option>
              <option value="time_h">Time hours</option>
              <option value="time_s">Time seconds</option>
            </select>
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Tap</div>
            <label style="display:flex; align-items:center; gap:8px; padding: 10px 6px; background: rgba(255,255,255,0.04); border-radius: 10px;">
              <input type="checkbox" id="mathTapCycles" />
              <span style="opacity:0.75; font-size: 12px;">Cycle operation on tap</span>
            </label>
          </div>
        </div>
        <div style="margin-top: 8px; font-size: 12px; opacity: 0.7;" id="mathStatusLine"></div>
      </div>

<!-- MONEY SETTINGS -->
      <div id="moneySettingsFields" class="cell-edit-section" style="display: none;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Money</div>
        <div class="cell-edit-grid-2">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Step</div>
            <input type="number" class="cell-edit-input" id="moneyStep" min="0" step="1" value="10" autocomplete="off">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Currency</div>
            <input type="text" class="cell-edit-input" id="moneyCurrency" maxlength="6" autocomplete="off" placeholder="€">
          </div>
        </div>
        <div class="cell-edit-field" id="moneyStartAmountField">
          <div class="cell-edit-label">Budget start amount</div>
          <input type="number" class="cell-edit-input" id="moneyStartAmount" min="0" autocomplete="off" placeholder="Optional">
        </div>
      </div>

      <!-- TIMER SETTINGS -->
      <div id="timerSettingsFields" class="cell-edit-section" style="display: none;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Timer</div>
        <div class="cell-edit-grid-2">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Duration (minutes)</div>
            <input type="number" class="cell-edit-input" id="timerDuration" min="1" max="999" value="20" autocomplete="off">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Display format</div>
            <div class="type-selector">
              <button class="type-btn active" data-format="mm:ss">MM:SS</button>
              <button class="type-btn" data-format="mm">MM</button>
            </div>
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Notification sound</div>
            <div class="cell-edit-inline">
              <select class="cell-edit-input" id="timerSound" style="padding: 8px;">
                <option value="soft_chime">Soft Chime</option>
                <option value="digital_pulse">Digital Pulse</option>
                <option value="organic_bell">Organic Bell</option>
                <option value="minimal_beep">Minimal Beep</option>
                <option value="ascending_trill">Ascending Trill</option>
              </select>
              <button type="button" class="sound-test-btn" id="timerSoundTest">▶</button>
            </div>
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Volume <span id="volumeValue">50%</span></div>
            <input type="range" id="timerVolume" min="0" max="100" value="50" style="width: 100%; height: 4px; background: rgba(255,255,255,0.2);">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Vibration</div>
            <div class="type-selector">
              <button class="type-btn active" data-vibrate="on">ON</button>
              <button class="type-btn" data-vibrate="off">OFF</button>
            </div>
          </div>
          <div class="cell-edit-field cell-edit-field-full">
            <div class="cell-edit-label">Custom message (optional)</div>
            <input type="text" class="cell-edit-input" id="timerMessage" maxlength="50" autocomplete="off" placeholder="Leave empty for default">
          </div>
        </div>
      </div>

      <!-- COUNTDOWN SETTINGS -->
      <div id="countdownSettingsFields" class="cell-edit-section" style="display: none;">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Countdown</div>
        <div class="cell-edit-grid-2">
          <div class="cell-edit-field">
            <div class="cell-edit-label">Target date</div>
            <input type="date" class="cell-edit-input" id="countdownDate" autocomplete="off">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Target time</div>
            <input type="time" class="cell-edit-input" id="countdownTime" value="12:00" autocomplete="off">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Notification sound</div>
            <div class="cell-edit-inline">
              <select class="cell-edit-input" id="countdownSound" style="padding: 8px;">
                <option value="soft_chime">Soft Chime</option>
                <option value="digital_pulse">Digital Pulse</option>
                <option value="organic_bell">Organic Bell</option>
                <option value="minimal_beep">Minimal Beep</option>
                <option value="ascending_trill">Ascending Trill</option>
              </select>
              <button type="button" class="sound-test-btn" id="countdownSoundTest">▶</button>
            </div>
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Volume <span id="countdownVolumeValue">50%</span></div>
            <input type="range" id="countdownVolume" min="0" max="100" value="50" style="width: 100%; height: 4px; background: rgba(255,255,255,0.2);">
          </div>
          <div class="cell-edit-field">
            <div class="cell-edit-label">Vibration</div>
            <div class="type-selector">
              <button class="type-btn active" data-vibrate-cd="on">ON</button>
              <button class="type-btn" data-vibrate-cd="off">OFF</button>
            </div>
          </div>
          <div class="cell-edit-field cell-edit-field-full">
            <div class="cell-edit-label">Custom message (optional)</div>
            <input type="text" class="cell-edit-input" id="countdownMessage" maxlength="50" autocomplete="off" placeholder="Leave empty for default">
          </div>
        </div>
      </div>

      <div style="margin-top: 8px;" id="descriptionField">
        <div class="cell-edit-label" style="margin-bottom: 8px;">Description</div>
        <input type="text" class="cell-edit-input" id="cellEditDescription" maxlength="30" autocomplete="off" placeholder="Optional description">
      </div><div class="color-picker-wrap">
        <div class="color-picker-label">Color</div>
        <input type="color" class="color-picker" id="cellEditColor" value="#ffffff">
      </div>

      <div class="modal-buttons">
        <button class="modal-btn" id="cellEditCancel">CANCEL</button>
        <button class="modal-btn primary" id="cellEditSave">SAVE</button>
      </div>
    </div>
  </div>

  <!-- INFO MODAL -->
  <div class="modal" id="infoModal">
    <div class="info-modal-content">
      <div class="info-header">
        <div class="info-logo">TRCKNG<br>SSTM</div>
        <div class="info-version">V0.99</div>
        <div class="info-author">DEV BY <a href="https://grisha-tsvetkov.com/" target="_blank">GRISHA TSVETKOV</a></div>
      </div>
      
      <div class="info-section">
        <div class="info-section-title">What's New in v0.99</div>
        <div class="info-text">
          <strong>UI IMPROVEMENTS:</strong><br>
          • Suffixes (s, m) now 5x smaller for cleaner look<br>
          • Fixed dash encoding in EDIT modal<br>
          • Duration Min now shows seconds in breakdown (0h 12m 32s)<br>
          <br>
          <strong>ANIMATED PROGRESS BORDER:</strong><br>
          • Timer/Countdown show animated circular progress<br>
          • Border completes full circle every 60 seconds<br>
          • Visual indicator for active timers/countdowns<br>
          <br>
          <strong>v0.63 FEATURES:</strong><br>
          • Countdown notifications with sound & vibration<br>
          • Click expired countdown to stop pulsing
        </div>
      </div>
      
      <div class="info-section">
        <div class="info-section-title">What is this?</div>
        <div class="info-text">
          Minimal weekly tracker. 9 customizable cells, 3 independent pages (pins), all data stored locally.
        </div>
      </div>

      <div class="info-section">
        <div class="info-section-title">Cell Types</div>
        <div class="info-text">
          <strong>Counter</strong> - tap to +1<br>
          <strong>Duration Sec</strong> - live MM:SS stopwatch<br>
          <strong>Duration Min</strong> - live minutes counter
        </div>
      </div>

      <div class="info-section">
        <div class="info-section-title">Controls</div>
        <div class="info-text">
          <strong>DECREASE</strong> - subtract mode / reset duration<br>
          <strong>COPY</strong> - copy current week<br>
          <strong>COPY PREV</strong> - copy previous week<br>
          <strong>EXPORT</strong> - download backup.json<br>
          <strong>IMPORT</strong> - restore from .json
        </div>
      </div>

      <div class="info-section">
        <div class="info-section-title">Install as App</div>
        <div class="info-text">
          <strong>iOS:</strong> Safari → Share → Add to Home Screen<br>
          <strong>Android:</strong> Chrome → Menu → Install app
        </div>
      </div>

      <div class="info-footer">
        <div class="info-buttons">
          <a href="https://buymeacoffee.com/comp1mov" target="_blank" class="info-button">Support Me</a>
          <a href="https://forms.gle/zgFWRNWtBvKzULr89" target="_blank" class="info-button">Feedback</a>
        </div>
        <button class="info-button" id="btnInfoClose" style="width: 100%;">CLOSE</button>
      </div>
    </div>
  </div>

  
  <!-- VALUE INPUT MODAL -->
  <div class="modal" id="valueModal">
    <div class="modal-content">
      <div class="modal-title" id="valueModalTitle">VALUE</div>
      <input type="number" inputmode="decimal" class="cell-edit-input" id="valueModalInput" autocomplete="off" style="font-size: 22px; text-align:center;">
      <div class="modal-buttons">
        <button class="modal-btn" id="valueModalClear">CLEAR</button>
        <button class="modal-btn" id="valueModalCancel">CANCEL</button>
        <button class="modal-btn" id="valueModalSave">SAVE</button>
      </div>
    </div>
  </div>

  <!-- THEME MODAL -->
  <div class="modal" id="themeModal">
    <div class="modal-content">
      <div class="modal-title">THEME</div>
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <div>
          <div class="cell-edit-label">App background</div>
          <input type="color" class="color-picker" id="themeBg" value="#000000">
        </div>
        <div>
          <div class="cell-edit-label">Text</div>
          <input type="color" class="color-picker" id="themeText" value="#ffffff">
        </div>
        <div>
          <div class="cell-edit-label">Button background</div>
          <input type="color" class="color-picker" id="themeBtnBg" value="#000000">
        </div>
        <div>
          <div class="cell-edit-label">Button text</div>
          <input type="color" class="color-picker" id="themeBtnText" value="#ffffff">
        </div>
      </div>
      <div style="margin-top: 10px;">
        <div class="cell-edit-label">Stroke</div>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
          <div>
            <div class="cell-edit-label" style="opacity:0.7;">Soft</div>
            <input type="color" class="color-picker" id="themeStrokeSoft" value="#ffffff">
          </div>
          <div>
            <div class="cell-edit-label" style="opacity:0.7;">Strong</div>
            <input type="color" class="color-picker" id="themeStrokeStrong" value="#ffffff">
          </div>
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn" id="themeReset">RESET</button>
        <button class="modal-btn" id="themeCancel">CANCEL</button>
        <button class="modal-btn" id="themeSave">SAVE</button>
      </div>
    </div>
  </div>

<script>
    'use strict';

    // ===== CONSTANTS =====
    const CELL_TYPES = {
      COUNTER: 'counter',   // legacy
      UNIT: 'unit',
      VALUE: 'value',
      MATH: 'math',
      DURATION_SEC: 'duration_sec',
      DURATION_MIN: 'duration_min',
      DURATION_SEC_COUNT: 'duration_sec_count',
      TIMER: 'timer',
      COUNTDOWN: 'countdown',
      MONEY_INCOME: 'money_income',
      MONEY_BUDGET: 'money_budget'
    };

    const STORAGE_KEYS = {
      DATA: 'trckng_sstm_data',
      LABELS: 'trckng_sstm_labels',
      TYPES: 'trckng_sstm_types',
      COLORS: 'trckng_sstm_colors',
      DESCRIPTIONS: 'trckng_sstm_descriptions',
      DURATION: 'trckng_sstm_duration',
      TIMER_SETTINGS: 'trckng_sstm_timer_settings',
      TIMER_STATES: 'trckng_sstm_timer_states',
      COUNTER_LAST_UPDATE: 'trckng_sstm_counter_last_update',
      MONEY_SETTINGS: 'trckng_sstm_money_settings',
      PIN_NAMES: 'trckng_sstm_pin_names',
      SEEN_INFO: 'trckng_has_seen_info'
    ,
      UNIT_SETTINGS: 'trckng_sstm_unit_settings',
      VALUE_FORMATS: 'trckng_sstm_value_formats',
      MATH_SETTINGS: 'trckng_sstm_math_settings',
      THEME: 'trckng_sstm_theme_settings'
    };

    const WEEKS_TO_KEEP = 52;
    const HABITS = ['cell01', 'cell02', 'cell03', 'cell04', 'cell05', 'cell06', 'cell07', 'cell08', 'cell09'];

    // Default configuration
    const DEFAULT_LABELS = {
      0: { cell01: 'Coffee', cell02: 'Smoke', cell03: 'Snacks', cell04: 'Road', cell05: 'Work', cell06: '', cell07: 'Sport', cell08: 'Outside', cell09: '' },
      1: { cell01: '', cell02: '', cell03: '', cell04: 'Focus', cell05: '', cell06: '', cell07: '', cell08: '', cell09: '' },
      2: { cell01: '', cell02: '', cell03: '', cell04: '', cell05: '', cell06: '', cell07: '', cell08: '', cell09: '' }
    };

    const DEFAULT_TYPES = {
      0: { cell01: 'counter', cell02: 'counter', cell03: 'counter', cell04: 'duration_sec', cell05: 'duration_min', cell06: 'counter', cell07: 'counter', cell08: 'duration_min', cell09: 'counter' },
      1: { cell01: 'counter', cell02: 'counter', cell03: 'counter', cell04: 'duration_sec', cell05: 'counter', cell06: 'counter', cell07: 'counter', cell08: 'counter', cell09: 'counter' },
      2: { cell01: 'counter', cell02: 'counter', cell03: 'counter', cell04: 'counter', cell05: 'counter', cell06: 'counter', cell07: 'counter', cell08: 'counter', cell09: 'counter' }
    };

    const DEFAULT_COLORS = {
      0: { cell01: '#c4a574', cell02: '#8b8b8b', cell03: '#ffab40', cell04: '#35f2a3', cell05: '#ff6b6b', cell06: '#ffffff', cell07: '#4da6ff', cell08: '#6bcb77', cell09: '#ffffff' },
      1: { cell01: '#ffffff', cell02: '#ffffff', cell03: '#ffffff', cell04: '#ff8c42', cell05: '#ffffff', cell06: '#ffffff', cell07: '#ffffff', cell08: '#ffffff', cell09: '#ffffff' },
      2: { cell01: '#ffffff', cell02: '#ffffff', cell03: '#ffffff', cell04: '#ffffff', cell05: '#ffffff', cell06: '#ffffff', cell07: '#ffffff', cell08: '#ffffff', cell09: '#ffffff' }
    };

    // ===== STATE =====
    let currentPin = 0;
    let currentWeekKey = getWeekKey();
    let decreaseMode = false;

    let weekData = {};
    let habitLabels = {};
    let habitTypes = {};
    let habitColors = {};
    let habitDescriptions = {};
    let durationStates = {};
    let timerSettings = {}; // Timer/Countdown configurations
    let unitSettings = {};
    let valueFormats = {};
    let mathSettings = {};
    let themeSettings = {};

    let timerStates = {}; // Runtime state (iterations, running status)
    let moneySettings = {}; // Money configs per habit
    let pinNames = {}; // Custom pin names
    let counterLastUpdate = {}; // Last update timestamps for simple counters
    let globalInterval = null;
    let clockInterval = null;
    let editingHabit = null;
    let audioContext = null;

    // ===== COLOR PALETTE =====
    function generateColorPalette() {
      const hour = new Date().getHours();
      const isNight = hour >= 20 || hour < 8;
      
      if (isNight) {
        return ['#9966ff', '#6699ff', '#66ccff', '#66ffcc', '#66ffff', '#ff8c42'];
      } else {
        return ['#ffcc44', '#ff9955', '#ff6677', '#ff44aa', '#cc55ff', '#ff8c42'];
      }
    }

    let colorPalette = generateColorPalette();
    let paletteIndex = 0;

    setInterval(() => {
      colorPalette = generateColorPalette();
    }, 3600000);

    function getAnimationColor(habit) {
      const customColor = habitColors[habit];
      const typeRaw = habitTypes[habit] || CELL_TYPES.UNIT;
      const type = (typeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : typeRaw;
      
      if (decreaseMode) return '#ff4f6a';
      
      if (customColor && customColor !== '#ffffff') return customColor;
      
      if (type === CELL_TYPES.DURATION_SEC) return '#35f2a3';
      if (type === CELL_TYPES.DURATION_MIN) return '#ff8c42';
      if (type === CELL_TYPES.DURATION_SEC_COUNT) return '#6b9dff';
      
      const color = colorPalette[paletteIndex % colorPalette.length];
      paletteIndex++;
      return color;
    }

    // ===== NOTIFICATION SOUNDS =====
    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Try to resume if context is suspended (some browsers pause it in background)
      if (audioContext.state === 'suspended') {
        audioContext.resume().catch(() => {});
      }
      return audioContext;
    }

    function playNotificationSound(soundType, volume) {
      const ctx = getAudioContext();
      const vol = volume / 100;

      switch(soundType) {
        case 'soft_chime':
          playSoftChime(ctx, vol);
          break;
        case 'digital_pulse':
          playDigitalPulse(ctx, vol);
          break;
        case 'organic_bell':
          playOrganicBell(ctx, vol);
          break;
        case 'minimal_beep':
          playMinimalBeep(ctx, vol);
          break;
        case 'ascending_trill':
          playAscendingTrill(ctx, vol);
          break;
      }
    }

    function playSoftChime(ctx, volume) {
      const notes = [523.25, 659.25, 783.99];
      const now = ctx.currentTime;
      for (let repeat = 0; repeat < 3; repeat++) {
        const repeatOffset = repeat * 1.1;
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          const startTime = now + repeatOffset + (i * 0.15);
          gain.gain.setValueAtTime(volume * 0.3, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(startTime);
          osc.stop(startTime + 0.5);
        });
      }
    }

    function playDigitalPulse(ctx, volume) {
      const now = ctx.currentTime;
      for (let repeat = 0; repeat < 3; repeat++) {
        const repeatOffset = repeat * 1.0;
        const osc1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        osc1.type = 'sine';
        osc1.frequency.value = 800;
        gain1.gain.setValueAtTime(volume * 0.4, now + repeatOffset);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + repeatOffset + 0.1);
        osc1.connect(gain1);
        gain1.connect(ctx.destination);
        osc1.start(now + repeatOffset);
        osc1.stop(now + repeatOffset + 0.15);

        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = 1000;
        gain2.gain.setValueAtTime(volume * 0.4, now + repeatOffset + 0.12);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + repeatOffset + 0.25);
        osc2.connect(gain2);
        gain2.connect(ctx.destination);
        osc2.start(now + repeatOffset + 0.12);
        osc2.stop(now + repeatOffset + 0.3);
      }
    }

    function playOrganicBell(ctx, volume) {
      const now = ctx.currentTime;
      const fundamental = 523.25;
      const harmonics = [1, 2, 3, 4.2, 5.4];
      for (let repeat = 0; repeat < 3; repeat++) {
        const repeatOffset = repeat * 1.4;
        harmonics.forEach((ratio, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = fundamental * ratio;
          const harmVolume = volume * (0.3 / (i + 1));
          gain.gain.setValueAtTime(harmVolume, now + repeatOffset);
          gain.gain.exponentialRampToValueAtTime(0.01, now + repeatOffset + 0.8);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(now + repeatOffset);
          osc.stop(now + repeatOffset + 1);
        });
      }
    }

    function playMinimalBeep(ctx, volume) {
      const now = ctx.currentTime;
      for (let repeat = 0; repeat < 3; repeat++) {
        const repeatOffset = repeat * 0.65;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 1000;
        gain.gain.setValueAtTime(volume * 0.4, now + repeatOffset);
        gain.gain.exponentialRampToValueAtTime(0.01, now + repeatOffset + 0.12);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now + repeatOffset);
        osc.stop(now + repeatOffset + 0.15);
      }
    }

    function playAscendingTrill(ctx, volume) {
      const notes = [500, 630, 800, 1000, 1200];
      const now = ctx.currentTime;
      for (let repeat = 0; repeat < 3; repeat++) {
        const repeatOffset = repeat * 1.0;
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          const startTime = now + repeatOffset + (i * 0.08);
          gain.gain.setValueAtTime(volume * 0.25, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.12);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(startTime);
          osc.stop(startTime + 0.15);
        });
      }
    }

    // ===== WEEK CALCULATION =====
    function firstMondayOfYear(year) {
      const jan1 = new Date(year, 0, 1);
      const dayOfWeek = jan1.getDay();
      const daysUntilMonday = (1 - dayOfWeek + 7) % 7;
      return new Date(year, 0, 1 + daysUntilMonday);
    }

    function getWeekKey(date = new Date()) {
      const y = date.getFullYear();
      const firstMonday = firstMondayOfYear(y);
      let weekYear = y, weekNum = 1;

      if (date < firstMonday) {
        weekYear = y - 1;
        const firstMondayPrev = firstMondayOfYear(y - 1);
        weekNum = 1 + Math.floor((date - firstMondayPrev) / (7 * 24 * 60 * 60 * 1000));
      } else {
        weekNum = 1 + Math.floor((date - firstMonday) / (7 * 24 * 60 * 60 * 1000));
      }
      return `${weekYear}W${String(weekNum).padStart(2, '0')}`;
    }

    function getWeekDateRange(weekKey) {
      const [yearStr, weekStr] = weekKey.split('W');
      const year = parseInt(yearStr);
      const week = parseInt(weekStr);
      const fm = firstMondayOfYear(year);
      const startDate = new Date(fm);
      startDate.setDate(fm.getDate() + (week - 1) * 7);
      const endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      return { start: startDate, end: endDate };
    }

    function formatDateRange(start, end) {
      const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
      return `${start.getDate()} ${months[start.getMonth()]} - ${end.getDate()} ${months[end.getMonth()]}`;
    }

    // ===== STORAGE =====
    function loadWeekData() {
      const key = `${STORAGE_KEYS.DATA}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      weekData = stored ? JSON.parse(stored) : {};
      
      Object.keys(weekData).forEach(week => {
        if (typeof weekData[week] !== 'object' || weekData[week] === null) {
          delete weekData[week];
        }
      });
    }

    function saveWeekData() {
      const key = `${STORAGE_KEYS.DATA}_pin${currentPin}`;
      const keys = Object.keys(weekData).sort().reverse();
      if (keys.length > WEEKS_TO_KEEP) {
        keys.slice(WEEKS_TO_KEEP).forEach(k => delete weekData[k]);
      }
      localStorage.setItem(key, JSON.stringify(weekData));
    }

    function loadLabels() {
      habitLabels = { ...DEFAULT_LABELS[currentPin] };
      const key = `${STORAGE_KEYS.LABELS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { Object.assign(habitLabels, JSON.parse(stored)); } catch(e) {}
      }
    }

    function saveLabels() {
      const key = `${STORAGE_KEYS.LABELS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(habitLabels));
    }

    function loadTypes() {
      habitTypes = { ...DEFAULT_TYPES[currentPin] };
      const key = `${STORAGE_KEYS.TYPES}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { Object.assign(habitTypes, JSON.parse(stored)); } catch(e) {}
      }
    }

    function saveTypes() {
      const key = `${STORAGE_KEYS.TYPES}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(habitTypes));
    }

    function loadColors() {
      habitColors = { ...DEFAULT_COLORS[currentPin] };
      const key = `${STORAGE_KEYS.COLORS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { Object.assign(habitColors, JSON.parse(stored)); } catch(e) {}
      }
    }

    function saveColors() {
      const key = `${STORAGE_KEYS.COLORS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(habitColors));
    }

    function loadDescriptions() {
      habitDescriptions = {};
      const key = `${STORAGE_KEYS.DESCRIPTIONS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { Object.assign(habitDescriptions, JSON.parse(stored)); } catch(e) {}
      }
    }

    function saveDescriptions() {
      const key = `${STORAGE_KEYS.DESCRIPTIONS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(habitDescriptions));
    }

    function loadDurationStates() {
      durationStates = {};
      const key = `${STORAGE_KEYS.DURATION}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { durationStates = JSON.parse(stored); } catch(e) {}
      }
    }

    function saveDurationStates() {
      const key = `${STORAGE_KEYS.DURATION}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(durationStates));
    }

    function loadTimerSettings() {
      timerSettings = {};
      const key = `${STORAGE_KEYS.TIMER_SETTINGS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { timerSettings = JSON.parse(stored); } catch(e) {}
      }

      // Ensure default settings for all TIMER / COUNTDOWN cells
      HABITS.forEach(habit => {
        const type = habitTypes[habit];
        const normalizedType = (type === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : type;

        // Live update for Math (so it reacts to running timers/durations)
        if (normalizedType === CELL_TYPES.MATH) {
          const cfg = mathSettings[habit] || {};
          const val = computeMathValue(habit, new Set());
          const valueEl = document.getElementById(`value-${habit}`);
          const breakdownEl = document.getElementById(`breakdown-${habit}`);
          if (valueEl) valueEl.innerHTML = formatMathDisplayValue(val, cfg);
          if (breakdownEl) breakdownEl.textContent = buildMathBreakdown(habit);
        }

        // Value has a static number but keep formatting stable if something external updates it
        if (normalizedType === CELL_TYPES.VALUE) {
          const valueEl = document.getElementById(`value-${habit}`);
          if (valueEl) valueEl.textContent = getValueDisplay(habit);
        }

        if ((type === CELL_TYPES.TIMER || type === CELL_TYPES.COUNTDOWN) && !timerSettings[habit]) {
          if (type === CELL_TYPES.TIMER) {
            timerSettings[habit] = {
              duration: 20,
              format: 'mm:ss',
              sound: 'soft_chime',
              volume: 50,
              vibrate: true,
              message: ''
            };
          } else if (type === CELL_TYPES.COUNTDOWN) {
            timerSettings[habit] = {
              targetDate: '',
              targetTime: '12:00',
              sound: 'soft_chime',
              volume: 50,
              vibrate: true,
              message: ''
            };
          }
        }
      });
    }

    function saveTimerSettings() {
      const key = `${STORAGE_KEYS.TIMER_SETTINGS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(timerSettings));
    }

    function loadTimerStates() {
      timerStates = {};
      const key = `${STORAGE_KEYS.TIMER_STATES}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { timerStates = JSON.parse(stored); } catch(e) {}
      }
    }

    function saveTimerStates() {
      const key = `${STORAGE_KEYS.TIMER_STATES}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(timerStates));
    }

    function loadMoneySettings() {
      moneySettings = {};
      const key = `${STORAGE_KEYS.MONEY_SETTINGS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { moneySettings = JSON.parse(stored); } catch(e) {}
      }
    }

    function saveMoneySettings() {
      const key = `${STORAGE_KEYS.MONEY_SETTINGS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(moneySettings));
    }

    function loadUnitSettings() {
      const key = `${STORAGE_KEYS.UNIT_SETTINGS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      unitSettings = stored ? JSON.parse(stored) : {};
    }
    function saveUnitSettings() {
      const key = `${STORAGE_KEYS.UNIT_SETTINGS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(unitSettings));
    }

    function loadValueFormats() {
      const key = `${STORAGE_KEYS.VALUE_FORMATS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      valueFormats = stored ? JSON.parse(stored) : {};
    }
    function saveValueFormats() {
      const key = `${STORAGE_KEYS.VALUE_FORMATS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(valueFormats));
    }

    function loadMathSettings() {
      const key = `${STORAGE_KEYS.MATH_SETTINGS}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      mathSettings = stored ? JSON.parse(stored) : {};
    }
    function saveMathSettings() {
      const key = `${STORAGE_KEYS.MATH_SETTINGS}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(mathSettings));
    }

    function defaultThemeSettings() {
      return {
        bg: '#000000',
        text: '#ffffff',
        btnBg: '#000000',
        btnText: '#ffffff',
        strokeSoft: '#ffffff',
        strokeStrong: '#ffffff'
      };
    }

    function loadThemeSettings() {
      const key = `${STORAGE_KEYS.THEME}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      themeSettings = stored ? JSON.parse(stored) : defaultThemeSettings();
    }
    function saveThemeSettings() {
      const key = `${STORAGE_KEYS.THEME}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(themeSettings));
    }

    
    function hexToRgba(hex, alpha) {
      if (!hex) return `rgba(255,255,255,${alpha})`;
      if (typeof hex === 'string' && hex.startsWith('rgba')) return hex;
      const h = hex.replace('#', '');
      if (h.length !== 6) return `rgba(255,255,255,${alpha})`;
      const r = parseInt(h.substring(0,2), 16);
      const g = parseInt(h.substring(2,4), 16);
      const b = parseInt(h.substring(4,6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
function applyTheme() {
      const t = themeSettings || defaultThemeSettings();
      document.documentElement.style.setProperty('--app-bg', t.bg || '#000000');
      document.documentElement.style.setProperty('--app-text', t.text || '#ffffff');
      document.documentElement.style.setProperty('--btn-bg', t.btnBg || '#000000');
      document.documentElement.style.setProperty('--btn-text', t.btnText || '#ffffff');

      const strokeSoft = hexToRgba(t.strokeSoft || '#ffffff', 0.15);
      const strokeStrong = hexToRgba(t.strokeStrong || '#ffffff', 0.35);
      document.documentElement.style.setProperty('--stroke-soft', strokeSoft);
      document.documentElement.style.setProperty('--stroke-strong', strokeStrong);
    }



    function loadCounterLastUpdate() {
      counterLastUpdate = {};
      const key = `${STORAGE_KEYS.COUNTER_LAST_UPDATE}_pin${currentPin}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try { counterLastUpdate = JSON.parse(stored); } catch (e) {}
      }
    }

    function saveCounterLastUpdate() {
      const key = `${STORAGE_KEYS.COUNTER_LAST_UPDATE}_pin${currentPin}`;
      localStorage.setItem(key, JSON.stringify(counterLastUpdate));
    }


    function loadPinNames() {
      pinNames = {};
      const stored = localStorage.getItem(STORAGE_KEYS.PIN_NAMES);
      if (stored) {
        try { pinNames = JSON.parse(stored) || {}; } catch (e) { pinNames = {}; }
      }
    }

    function savePinNames() {
      localStorage.setItem(STORAGE_KEYS.PIN_NAMES, JSON.stringify(pinNames));
    }

    function getDefaultPinName(index) {
      const num = String(index + 1).padStart(2, '0');
      return `PIN ${num}`;
    }

    function applyPinNamesToUI() {
      for (let i = 0; i < 3; i++) {
        const btn = document.getElementById(`pin${i}`);
        const raw = (pinNames && pinNames[i] != null) ? String(pinNames[i]) : '';
        const name = raw.trim() || getDefaultPinName(i);
        if (btn) btn.textContent = name;
      }

      const renameBtn = document.getElementById('btnEditPinName');
      if (renameBtn) {
        const raw = (pinNames && pinNames[currentPin] != null) ? String(pinNames[currentPin]) : '';
        const name = raw.trim() || getDefaultPinName(currentPin);
        renameBtn.textContent = name;
      }
    }


    function ensureWeekExists() {
      if (!weekData[currentWeekKey] || typeof weekData[currentWeekKey] !== 'object') {
        weekData[currentWeekKey] = {};
        saveWeekData();
      }
    }

    // ===== FORMATTING =====
    function formatValueWithSuffix(value, suffix) {
      return `${value}<span class="btn-value-suffix">${suffix}</span>`;
    }

    function formatDurationSec(totalSeconds) {
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      
      const main = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      const breakdown = `${hours}h ${minutes}m ${seconds}s`;
      
      return { main, breakdown };
    }

    function formatDurationMin(totalMinutes, totalSeconds = null) {
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      
      const main = String(totalMinutes).padStart(2, '0');
      
      // If totalSeconds provided, include them in breakdown
      let breakdown;
      if (totalSeconds !== null) {
        const secs = totalSeconds % 60;
        breakdown = `${hours}h ${minutes}m ${secs}s`;
      } else {
        breakdown = `${hours}h ${minutes}m`;
      }
      
      return { main, breakdown };
    }

    function formatCounterLastUpdate(habit) {
      const ts = counterLastUpdate[habit];
      if (!ts) return '';
      const now = Date.now();
      let diffSec = Math.floor((now - ts) / 1000);
      if (diffSec < 0) diffSec = 0;

      const oneMinute = 60;
      const oneHour = 3600;
      const oneDay = 86400;

      if (diffSec < oneMinute) {
        return `${diffSec}s ago`;
      } else if (diffSec < oneHour) {
        const m = Math.floor(diffSec / 60);
        const s = diffSec % 60;
        return `${m}:${String(s).padStart(2, '0')}s ago`;
      } else if (diffSec < oneDay) {
        const h = Math.floor(diffSec / 3600);
        const m = Math.floor((diffSec % 3600) / 60);
        return `${h}h ${String(m).padStart(2, '0')}m ago`;
      } else {
        const d = new Date(ts);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}.${month} ${hours}:${minutes}`;
      }
    }


    // ===== CLICK HANDLERS =====
    function handleHabitClick(habit) {
      const label = habitLabels[habit];
      if (!label?.trim()) return;

      const typeRaw = habitTypes[habit] || CELL_TYPES.UNIT;
      const type = (typeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : typeRaw;

      if (type === CELL_TYPES.UNIT) {
        handleUnitClick(habit);
      } else if (type === CELL_TYPES.VALUE) {
        openValueModal(habit);
      } else if (type === CELL_TYPES.MATH) {
        const cfg = mathSettings[habit] || {};
        if (cfg.tapCycles === true) {
          cycleMathOp(habit);
        }
      } else if (type === CELL_TYPES.MONEY_INCOME || type === CELL_TYPES.MONEY_BUDGET) {
        handleMoneyClick(habit, type);
      } else if (type === CELL_TYPES.TIMER) {
        handleTimerClick(habit);
      } else if (type === CELL_TYPES.COUNTDOWN) {
        handleCountdownClick(habit);
      } else {
        handleDurationClick(habit, type);
      }
    }

    function handleCounterClick(habit) {
      ensureWeekExists();
      if (decreaseMode) {
        weekData[currentWeekKey][habit] = Math.max(0, (weekData[currentWeekKey][habit] || 0) - 1);
      } else {
        weekData[currentWeekKey][habit] = (weekData[currentWeekKey][habit] || 0) + 1;
      }

      // Track last update time for simple counters
      counterLastUpdate[habit] = Date.now();

      saveWeekData();
      saveCounterLastUpdate();
      updateCellDisplay(habit);
      animateButton(habit);
    }

    function handleUnitClick(habit) {
      ensureWeekExists();
      const step = getUnitStep(habit);

      if (decreaseMode) {
        weekData[currentWeekKey][habit] = Math.max(0, (weekData[currentWeekKey][habit] || 0) - step);
      } else {
        weekData[currentWeekKey][habit] = (weekData[currentWeekKey][habit] || 0) + step;
      }

      counterLastUpdate[habit] = Date.now();
      saveWeekData();
      saveCounterLastUpdate();

      // Update display depending on total flag
      const el = document.getElementById(`value-${habit}`);
      if (el) el.textContent = String(getUnitDisplayValue(habit));
      scheduleMathRefresh();
      animateButton(habit);
    }

    let editingValueHabit = null;

    function openValueModal(habit) {
      editingValueHabit = habit;
      const label = habitLabels[habit] || habit;
      document.getElementById('valueModalTitle').textContent = `VALUE · ${label}`;
      ensureWeekExists();
      const weekObj = weekData[currentWeekKey] || {};
      const current = Number(weekObj[habit] || 0);
      document.getElementById('valueModalInput').value = Number.isFinite(current) ? current : 0;
      document.getElementById('valueModal').classList.add('visible');
      setTimeout(() => document.getElementById('valueModalInput').focus(), 60);
    }

    function closeValueModal() {
      document.getElementById('valueModal').classList.remove('visible');
      editingValueHabit = null;
    }



    // ===== UNIT / VALUE / MATH HELPERS =====
    function getUnitStep(habit) {
      const cfg = unitSettings[habit] || {};
      const step = Number(cfg.step);
      if (!Number.isFinite(step) || step <= 0) return 1;
      return Math.floor(step);
    }

    function getUnitTotalFlag(habit) {
      const cfg = unitSettings[habit] || {};
      return cfg.total === true;
    }

    function getUnitDisplayValue(habit) {
      if (getUnitTotalFlag(habit)) {
        let sum = 0;
        Object.keys(weekData || {}).forEach(weekKey => {
          const w = weekData[weekKey];
          if (w && typeof w === 'object') sum += Number(w[habit] || 0);
        });
        return sum;
      }
      const weekObj = weekData[currentWeekKey];
      return (weekObj && typeof weekObj === 'object') ? Number(weekObj[habit] || 0) : 0;
    }

    function formatValueByFormat(value, fmt) {
      if (!Number.isFinite(value)) return '--';

      // Numeric formats
      if (fmt === 'int') return String(Math.round(value));
      if (fmt === '2dp') return String(Math.round(value * 100) / 100);
      if (fmt === '3dp') return String(Math.round(value * 1000) / 1000);

      // Time display helpers (Value stores a plain number; for time formats we interpret it as seconds)
      if (fmt === 'time_mmss') {
        const secs = Math.max(0, Math.floor(value));
        return formatDurationSec(secs).main;
      }
      if (fmt === 'time_m') {
        const mins = Math.max(0, (value / 60));
        const rounded = Math.round(mins * 100) / 100;
        return formatValueWithSuffix(rounded, 'm');
      }
      if (fmt === 'time_h') {
        const hrs = Math.max(0, (value / 3600));
        const rounded = Math.round(hrs * 100) / 100;
        return formatValueWithSuffix(rounded, 'h');
      }
      if (fmt === 'time_s') {
        const secs = Math.max(0, Math.floor(value));
        return formatValueWithSuffix(secs, 's');
      }

      return String(value);
    }

    function getValueDisplay(habit) {
      const weekObj = weekData[currentWeekKey];
      const v = (weekObj && typeof weekObj === 'object') ? Number(weekObj[habit] || 0) : 0;
      const fmt = valueFormats[habit] || 'raw';
      return formatValueByFormat(v, fmt);
    }

    function computeDurationTotalSeconds(habit) {
      const state = durationStates[habit] || {};
      const accumulated = Number(state.accumulated || 0);
      let total = accumulated;
      if (state.isRunning && state.startTime) {
        total += Math.floor((Date.now() - state.startTime) / 1000);
      }
      return Math.max(0, Math.floor(total));
    }

    function computeTimerElapsedSeconds(habit) {
      const st = timerStates[habit] || {};
      if (!st.isRunning || !st.startTime) return 0;
      const elapsedMs = Date.now() - st.startTime;
      return Math.max(0, Math.floor(elapsedMs / 1000));
    }

    function computeCountdownSecondsLeft(habit) {
      const cfg = timerSettings[habit] || {};
      if (!cfg.targetDate || !cfg.targetTime) return 0;
      const dt = new Date(`${cfg.targetDate}T${cfg.targetTime}:00`);
      if (isNaN(dt.getTime())) return 0;
      const diffMs = dt.getTime() - Date.now();
      return Math.max(0, Math.floor(diffMs / 1000));
    }

    function getNumericForHabit(habit, visited = new Set()) {
      if (!habit) return NaN;
      if (visited.has(habit)) return NaN;
      visited.add(habit);

      const tRaw = habitTypes[habit] || CELL_TYPES.UNIT;
      const t = (tRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : tRaw;

      if (t === CELL_TYPES.UNIT) return getUnitDisplayValue(habit);
      if (t === CELL_TYPES.VALUE) {
        const weekObj = weekData[currentWeekKey];
        return (weekObj && typeof weekObj === 'object') ? Number(weekObj[habit] || 0) : 0;
      }
      if (t === CELL_TYPES.MONEY_INCOME || t === CELL_TYPES.MONEY_BUDGET) {
        const weekObj = weekData[currentWeekKey];
        return (weekObj && typeof weekObj === 'object') ? Number(weekObj[habit] || 0) : 0;
      }
      if (t === CELL_TYPES.DURATION_SEC || t === CELL_TYPES.DURATION_SEC_COUNT) return computeDurationTotalSeconds(habit);
      if (t === CELL_TYPES.DURATION_MIN) return computeDurationTotalSeconds(habit); // unified: seconds
      if (t === CELL_TYPES.TIMER) return computeTimerElapsedSeconds(habit); // unified: seconds elapsed while running
      if (t === CELL_TYPES.COUNTDOWN) return computeCountdownSecondsLeft(habit); // unified: seconds left
      if (t === CELL_TYPES.MATH) return computeMathValue(habit, visited);

      return NaN;
    }

    function computeMathValue(habit, visited = new Set()) {
      const cfg = mathSettings[habit] || {};
      const a = cfg.a;
      const op = cfg.op || 'add';
      const bMode = cfg.bMode || 'cell';
      const bCell = cfg.b;
      const bNum = Number(cfg.bNum != null ? cfg.bNum : 1);

      const av = getNumericForHabit(a, visited);
      let bv = NaN;

      const isUnary = (op === 'pow2' || op === 'cos' || op === 'abs' || op === 'round' || op === 'floor' || op === 'ceil');
      if (isUnary) {
        bv = 0;
      } else {
        bv = (bMode === 'number') ? bNum : getNumericForHabit(bCell, visited);
      }

      if (!Number.isFinite(av) || (!isUnary && !Number.isFinite(bv))) return NaN;

      switch (op) {
        case 'add': return av + bv;
        case 'sub': return av - bv;
        case 'mul': return av * bv;
        case 'div': return bv === 0 ? NaN : (av / bv);
        case 'min': return Math.min(av, bv);
        case 'max': return Math.max(av, bv);
        case 'pow2': return av * av;
        case 'abs': return Math.abs(av);
        case 'round': return Math.round(av);
        case 'floor': return Math.floor(av);
        case 'ceil': return Math.ceil(av);
        case 'cos': return Math.cos(av);
        default: return NaN;
      }
    }



    function mathOpToHuman(op) {
      switch (op) {
        case 'add': return '+';
        case 'sub': return '−';
        case 'mul': return '×';
        case 'div': return '÷';
        case 'min': return 'min';
        case 'max': return 'max';
        case 'pow2': return 'x²';
        case 'abs': return 'abs';
        case 'round': return 'round';
        case 'floor': return 'floor';
        case 'ceil': return 'ceil';
        case 'cos': return 'cos';
        default: return op || '?';
      }
    }

    function formatMathDisplayValue(value, cfg) {
      if (!Number.isFinite(value)) return '--';

      const mode = (cfg && cfg.formatFrom) ? cfg.formatFrom : 'a';

      // Explicit formats (do not depend on A/B types)
      if (mode === 'raw') {
        const rounded = Math.round(value * 1000) / 1000;
        return String(rounded);
      }
      if (mode === 'int') return String(Math.round(value));
      if (mode === '2dp') return String(Math.round(value * 100) / 100);
      if (mode === '3dp') return String(Math.round(value * 1000) / 1000);

      if (mode === 'time_mmss') {
        const secs = Math.max(0, Math.floor(value));
        return formatDurationSec(secs).main;
      }
      if (mode === 'time_m') {
        const mins = Math.max(0, (value / 60));
        const rounded = Math.round(mins * 100) / 100;
        return formatValueWithSuffix(rounded, 'm');
      }
      if (mode === 'time_h') {
        const hrs = Math.max(0, (value / 3600));
        const rounded = Math.round(hrs * 100) / 100;
        return formatValueWithSuffix(rounded, 'h');
      }
      if (mode === 'time_s') {
        const secs = Math.max(0, Math.floor(value));
        return formatValueWithSuffix(secs, 's');
      }

      // Auto like A / Auto like B
      const refHabit = (mode === 'b') ? cfg.b : cfg.a;
      const refTypeRaw = habitTypes[refHabit] || CELL_TYPES.UNIT;
      const refType = (refTypeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : refTypeRaw;

      // Money formatting
      if (refType === CELL_TYPES.MONEY_INCOME || refType === CELL_TYPES.MONEY_BUDGET) {
        const cur = (moneySettings[refHabit] && moneySettings[refHabit].currency) ? moneySettings[refHabit].currency : '€';
        const rounded = Math.round(value * 100) / 100;
        return formatValueWithSuffix(rounded, cur);
      }

      // Time types (Math uses unified seconds)
      if (refType === CELL_TYPES.DURATION_SEC || refType === CELL_TYPES.DURATION_SEC_COUNT) {
        const secs = Math.max(0, Math.floor(value));
        return formatDurationSec(secs).main;
      }

      if (refType === CELL_TYPES.DURATION_MIN) {
        const mins = Math.max(0, Math.floor(value / 60));
        const fmt = formatDurationMin(mins);
        return formatValueWithSuffix(fmt.main, 'm');
      }

      // Timer: unified seconds elapsed while running
      if (refType === CELL_TYPES.TIMER) {
        const secs = Math.max(0, Math.floor(value));
        return formatDurationSec(secs).main;
      }

      // Countdown: unified seconds left, show hours as the "native" view
      if (refType === CELL_TYPES.COUNTDOWN) {
        const hrs = Math.max(0, Math.ceil(value / 3600));
        return formatValueWithSuffix(hrs, 'h');
      }

      // Default numeric
      const rounded = Math.round(value * 1000) / 1000;
      return String(rounded);
    }


    function buildMathBreakdown(habit) {
      const cfg = mathSettings[habit] || {};
      const a = cfg.a;
      const op = cfg.op || 'add';
      const bMode = cfg.bMode || 'cell';

      const aLabel = habitLabels[a] || a || 'A';
      const symbol = mathOpToHuman(op);

      if (op === 'pow2') return `${aLabel} ${symbol}`;
      if (op === 'cos') return `${symbol}(${aLabel})`;
      if (op === 'abs' || op === 'round' || op === 'floor' || op === 'ceil') return `${symbol}(${aLabel})`;

      if (bMode === 'number') {
        const bNum = (cfg.bNum != null) ? cfg.bNum : 1;
        return (op === 'min' || op === 'max') ? `${symbol}(${aLabel}, ${bNum})` : `${aLabel} ${symbol} ${bNum}`;
      }

      const b = cfg.b;
      const bLabel = habitLabels[b] || b || 'B';
      return (op === 'min' || op === 'max') ? `${symbol}(${aLabel}, ${bLabel})` : `${aLabel} ${symbol} ${bLabel}`;
    }

    function wouldCreateMathCycle(targetHabit) {
      const cfg = mathSettings[targetHabit] || {};
      const deps = [];
      if (cfg.a) deps.push(cfg.a);
      if (!(['pow2','cos','abs','round','floor','ceil'].includes(cfg.op)) && cfg.bMode !== 'number' && cfg.b) deps.push(cfg.b);

      const stack = new Set([targetHabit]);

      const dfs = (h) => {
        if (!h) return false;
        if (stack.has(h)) return true;
        const tRaw = habitTypes[h] || CELL_TYPES.UNIT;
        const t = (tRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : tRaw;
        if (t !== CELL_TYPES.MATH) return false;

        stack.add(h);
        const c = mathSettings[h] || {};
        const next = [];
        if (c.a) next.push(c.a);
        if (!(['pow2','cos','abs','round','floor','ceil'].includes(c.op)) && c.bMode !== 'number' && c.b) next.push(c.b);

        for (const n of next) {
          if (dfs(n)) return true;
        }
        stack.delete(h);
        return false;
      };

      for (const d of deps) {
        if (dfs(d)) return true;
      }
      return false;
    }

    function cycleMathOp(habit) {
      const cfg = mathSettings[habit] || {};
      const order = ['add', 'sub', 'mul', 'div', 'min', 'max', 'pow2', 'abs', 'round', 'floor', 'ceil', 'cos'];
      const cur = cfg.op || 'add';
      const idx = order.indexOf(cur);
      const next = order[(idx + 1 + order.length) % order.length];
      cfg.op = next;
      mathSettings[habit] = cfg;
      saveMathSettings();
      renderHabits();
    }

    function attachUnitPressHandlers(btn, habit) {
      let pressTimer = null;

      const stepOnce = () => handleUnitClick(habit);

      const startPress = (event) => {
        event.preventDefault();
        stepOnce();
        if (pressTimer) clearInterval(pressTimer);
        pressTimer = setInterval(stepOnce, 160);
      };

      const stopPress = () => {
        if (pressTimer) {
          clearInterval(pressTimer);
          pressTimer = null;
        }
      };

      btn.addEventListener('mousedown', startPress);
      btn.addEventListener('touchstart', startPress);

      ['mouseup', 'mouseleave', 'touchend', 'touchcancel'].forEach(ev => {
        btn.addEventListener(ev, stopPress);
      });
    }



    
    function handleMoneyClick(habit, type) {
      ensureWeekExists();

      const cfg = moneySettings[habit] || {};
      const baseStep = cfg.step != null ? Math.abs(cfg.step) : 10;
      const step = baseStep === 0 ? 1 : baseStep;

      const isIncome = type === CELL_TYPES.MONEY_INCOME;

      // Базовое направление: income увеличивает, budget уменьшает
      let delta = isIncome ? step : -step;

      // В режиме DECREASE инвертируем знак
      if (decreaseMode) {
        delta = -delta;
      }

      let weekObj = weekData[currentWeekKey] || {};
      if (!weekObj || typeof weekObj !== 'object') {
        weekObj = {};
        weekData[currentWeekKey] = weekObj;
      }

      if (weekObj[habit] === undefined || weekObj[habit] === null) {
        if (!isIncome && cfg.startAmount != null) {
          weekObj[habit] = Number(cfg.startAmount) || 0;
        } else {
          weekObj[habit] = 0;
        }
      }

      let next = (Number(weekObj[habit]) || 0) + delta;

      // Для бюджета не даем уйти в минус
      if (!isIncome && next < 0) next = 0;

      weekObj[habit] = next;

      saveWeekData();
      updateMoneyCellDisplay(habit, type);
      scheduleMathRefresh();
      animateButton(habit);
    }
function attachMoneyPressHandlers(btn, habit, type) {
      let pressTimer = null;

      const stepOnce = () => handleMoneyClick(habit, type);

      const startPress = (event) => {
        event.preventDefault();
        stepOnce();
        if (pressTimer) clearInterval(pressTimer);
        pressTimer = setInterval(stepOnce, 160);
      };

      const stopPress = () => {
        if (pressTimer) {
          clearInterval(pressTimer);
          pressTimer = null;
        }
      };

      btn.addEventListener('mousedown', startPress);
      btn.addEventListener('touchstart', startPress);

      ['mouseup', 'mouseleave', 'touchend', 'touchcancel'].forEach(ev => {
        btn.addEventListener(ev, stopPress);
      });
    }


function handleDurationClick(habit, type) {
      const state = durationStates[habit] || { startTime: null, isRunning: false, accumulated: 0, lastSession: 0 };

      if (decreaseMode) {
        durationStates[habit] = { startTime: null, isRunning: false, accumulated: 0, lastSession: 0 };
        saveDurationStates();
        renderHabits();
        animateButton(habit);
        return;
      }

      if (!state.isRunning) {
        const now = Date.now();
        durationStates[habit] = {
          startTime: now,
          isRunning: true,
          accumulated: state.accumulated || 0,
          lastSession: 0
        };
        startGlobalInterval();
      } else {
        const elapsed = Math.max(0, Math.floor((Date.now() - state.startTime) / 1000));
        const newAccumulated = (state.accumulated || 0) + elapsed;

        const nextState = {
          startTime: null,
          isRunning: false,
          accumulated: newAccumulated
        };

        // For second-based duration, remember the last session length
        if (type === CELL_TYPES.DURATION_SEC) {
          nextState.lastSession = elapsed;
        }

        durationStates[habit] = nextState;

        ensureWeekExists();
        if (type === CELL_TYPES.DURATION_MIN) {
          weekData[currentWeekKey][habit] = Math.floor(newAccumulated / 60);
        } else {
          weekData[currentWeekKey][habit] = newAccumulated;
        }
        saveWeekData();
      }

      saveDurationStates();
      renderHabits();
      animateButton(habit);
    }

    function handleTimerClick(habit) {
      const state = timerStates[habit] || { isRunning: false, startTime: null, remaining: null, iterations: 0 };
      const settings = timerSettings[habit] || { duration: 20 };

      if (decreaseMode) {
        // Reset iterations
        timerStates[habit] = { isRunning: false, startTime: null, remaining: null, iterations: 0 };
        saveTimerStates();
        renderHabits();
        animateButton(habit);
        return;
      }

      if (!state.isRunning) {
        // Start timer
        const durationMs = (settings.duration || 20) * 60 * 1000;
        timerStates[habit] = {
          isRunning: true,
          startTime: Date.now(),
          remaining: state.remaining !== null ? state.remaining : durationMs,
          iterations: state.iterations || 0
        };
        startGlobalInterval();
      } else {
        // Pause/Stop timer - return to original time
        const durationMs = (settings.duration || 20) * 60 * 1000;
        timerStates[habit] = {
          isRunning: false,
          startTime: null,
          remaining: durationMs,
          iterations: state.iterations || 0
        };
      }

      saveTimerStates();
      renderHabits();
      animateButton(habit);
    }

    function handleCountdownClick(habit) {
      // If countdown expired and pulsing - stop pulsing and reset notification flag,
      // и в любом случае даём визуальный отклик на клик
      const settings = timerSettings[habit] || {};
      if (settings.targetDate) {
        const targetDateTime = new Date(`${settings.targetDate}T${settings.targetTime || '12:00'}`);
        const now = new Date();
        const diff = targetDateTime - now;

        if (diff <= 0) {
          // Stop pulsing
          const btn = document.getElementById(`btn-${habit}`);
          if (btn) btn.classList.remove('pulsing');

          // Reset notification flag so it can be sent again if needed
          const state = timerStates[habit] || {};
          timerStates[habit] = { ...state, notificationSent: false };
          saveTimerStates();
        }
      }

      // Лёгкий клик-фидбек по аналогии с другими слотами
      animateButton(habit);
    }


    // Timer notification messages
    function getTimerNotificationMessage(iterations, duration, customMessage) {
      if (customMessage && customMessage.trim()) {
        return customMessage;
      }

      const messages = [
        `Timer complete • ${duration}min`,
        `Session 2 finished • ${duration}min`,
        `Round 3 done • ${duration}min`,
        `Cycle 4 complete • ${duration}min`,
        `Phase 5 finished • ${duration}min`
      ];

      if (iterations === 0) return messages[0];
      if (iterations === 1) return messages[1];
      if (iterations === 2) return messages[2];
      if (iterations === 3) return messages[3];
      if (iterations === 4) return messages[4];
      return `Session ${iterations + 1} complete • ${duration}min`;
    }

    function sendTimerNotification(habit) {
      const settings = timerSettings[habit] || {};
      const state = timerStates[habit] || {};
      const label = habitLabels[habit] || 'Timer';
      
      const message = getTimerNotificationMessage(
        state.iterations || 0,
        settings.duration || 20,
        settings.message
      );

      // Play sound with defaults
      const soundType = settings.sound || 'soft_chime';
      const volume = typeof settings.volume === 'number' ? settings.volume : 50;
      if (volume > 0) {
        playNotificationSound(soundType, volume);
      }

      // Vibrate
      if (settings.vibrate && navigator.vibrate) {
        navigator.vibrate([200, 100, 200]);
      }

      // Browser notification
      if (Notification.permission === 'granted') {
        new Notification(`${label}`, {
          body: message,
          icon: '/TRCKNG-SSTM/icons/icon-192.png',
          tag: `timer-${habit}`
        });
      }
    }

    function sendCountdownNotification(habit) {
      const settings = timerSettings[habit] || {};
      const label = habitLabels[habit] || 'Countdown';
      
      // Default message or custom message
      const message = settings.message && settings.message.trim() 
        ? settings.message 
        : 'Time is up!';

      // Play sound with defaults
      const soundType = settings.sound || 'soft_chime';
      const volume = typeof settings.volume === 'number' ? settings.volume : 50;
      if (volume > 0) {
        playNotificationSound(soundType, volume);
      }

      // Vibrate
      if (settings.vibrate && navigator.vibrate) {
        navigator.vibrate([200, 100, 200]);
      }

      // Browser notification
      if (Notification.permission === 'granted') {
        new Notification(`${label}`, {
          body: message,
          icon: '/TRCKNG-SSTM/icons/icon-192.png',
          tag: `countdown-${habit}`
        });
      }
    }

    function animateButton(habit) {
      const btn = document.getElementById(`btn-${habit}`);
      if (!btn) return;
      
      const animColor = getAnimationColor(habit);
      btn.style.setProperty('--btn-color', animColor);
      
      btn.classList.remove('animating');
      void btn.offsetWidth;
      btn.classList.add('animating');
      setTimeout(() => btn.classList.remove('animating'), 1500);
    }

    // ===== COMPUTED CELLS LIVE REFRESH (Math) =====
let _mathRefreshScheduled = false;

function updateAllMathDisplays() {
  HABITS.forEach(habit => {
    const label = habitLabels[habit];
    if (!label || !label.trim()) return;

    const typeRaw = habitTypes[habit] || CELL_TYPES.UNIT;
    const type = (typeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : typeRaw;
    if (type !== CELL_TYPES.MATH) return;

    const cfg = mathSettings[habit] || {};
    const val = computeMathValue(habit, new Set());

    const valueEl = document.getElementById(`value-${habit}`);
    const breakdownEl = document.getElementById(`breakdown-${habit}`);
    if (valueEl) valueEl.innerHTML = formatMathDisplayValue(val, cfg);
    if (breakdownEl) breakdownEl.textContent = buildMathBreakdown(habit);
  });
}

function scheduleMathRefresh() {
  if (_mathRefreshScheduled) return;
  _mathRefreshScheduled = true;
  requestAnimationFrame(() => {
    _mathRefreshScheduled = false;
    updateAllMathDisplays();
  });
}

    // ===== INTERVAL =====
    function startGlobalInterval() {
      if (globalInterval) return;
      globalInterval = setInterval(updateLiveDisplays, 1000);
    }

    function stopGlobalIntervalIfNeeded() {
      const hasRunning = Object.values(durationStates).some(s => s.isRunning);
      if (!hasRunning && globalInterval) {
        clearInterval(globalInterval);
        globalInterval = null;
      }
    }

    function updateLiveDisplays() {
      HABITS.forEach(habit => {
        const type = habitTypes[habit];

        // Live update for simple counters: "X ago" label
        if (type === CELL_TYPES.COUNTER || type === CELL_TYPES.UNIT) {
          const breakdownEl = document.getElementById(`breakdown-${habit}`);
          if (breakdownEl) {
            const description = habitDescriptions[habit] || '';
            const lastUpdateLabel = formatCounterLastUpdate(habit);
            breakdownEl.textContent = lastUpdateLabel || description;
          }
        }

        // Handle duration types
        const state = durationStates[habit];
        if (state?.isRunning) {
          const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
          const total = (state.accumulated || 0) + elapsed;

          const valueEl = document.getElementById(`value-${habit}`);
          const breakdownEl = document.getElementById(`breakdown-${habit}`);
          const description = habitDescriptions[habit];

          // Calculate progress for animated border (0-100% over 60 seconds)
          const secondsInMinute = total % 60;
          const progress = ((60 - secondsInMinute) / 60) * 100;
          const btn = document.getElementById(`btn-${habit}`);
          if (btn) {
            btn.style.setProperty('--progress', progress);
          }

          if (type === CELL_TYPES.DURATION_SEC) {
            // Live update: main value shows current session, breakdown shows total
            const sessionSeconds = elapsed;
            const fmtSession = formatDurationSec(sessionSeconds);
            if (valueEl) valueEl.innerHTML = formatValueWithSuffix(fmtSession.main, 's');

            const fmtTotal = formatDurationSec(total);
            if (breakdownEl) breakdownEl.textContent = description || fmtTotal.breakdown;
          } else if (type === CELL_TYPES.DURATION_MIN) {
            const totalMin = Math.floor(total / 60);
            const fmt = formatDurationMin(totalMin, total);
            if (valueEl) valueEl.innerHTML = formatValueWithSuffix(fmt.main, 'm');
            if (breakdownEl) breakdownEl.textContent = description || fmt.breakdown;
          } else if (type === CELL_TYPES.DURATION_SEC_COUNT) {
            const fmt = formatDurationSec(total);
            if (valueEl) valueEl.innerHTML = formatValueWithSuffix(total, 's');
            if (breakdownEl) breakdownEl.textContent = description || fmt.breakdown;
          }
        }

        // Handle Timer
        const timerState = timerStates[habit];
        if (type === CELL_TYPES.TIMER && timerState?.isRunning) {
          const elapsed = Date.now() - timerState.startTime;
          const remaining = Math.max(0, timerState.remaining - elapsed);
          
          const valueEl = document.getElementById(`value-${habit}`);
          const breakdownEl = document.getElementById(`breakdown-${habit}`);
          
          if (remaining <= 0) {
            // Timer finished - trigger notification and restart
            const settings = timerSettings[habit] || {};
            const newcycless = (timerState.iterations || 0) + 1;
            
            sendTimerNotification(habit);
            
            // Auto-restart
            const durationMs = (settings.duration || 20) * 60 * 1000;
            timerStates[habit] = {
              isRunning: true,
              startTime: Date.now(),
              remaining: durationMs,
              iterations: newcycless
            };
            saveTimerStates();
            renderHabits(); // Re-render to show new iteration count
          } else {
            // Update display
            const seconds = Math.floor(remaining / 1000);
            const settings = timerSettings[habit] || {};
            
            // Calculate progress for animated border (0-100% over 60 seconds)
            const secondsInMinute = seconds % 60;
            const progress = ((60 - secondsInMinute) / 60) * 100;
            const btn = document.getElementById(`btn-${habit}`);
            if (btn) {
              btn.style.setProperty('--progress', progress);
            }
            
            if (settings.format === 'mm') {
              const minutes = Math.ceil(seconds / 60);
              if (valueEl) valueEl.innerHTML = formatValueWithSuffix(minutes, 'm');
            } else {
              const m = Math.floor(seconds / 60);
              const s = seconds % 60;
              if (valueEl) valueEl.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }
            
            if (breakdownEl) {
              breakdownEl.textContent = `timer cycles ${(timerState.iterations || 0) + 1}`;
            }
          }
        }

        // Handle Countdown
        if (type === CELL_TYPES.COUNTDOWN) {
          const settings = timerSettings[habit];
          if (settings?.targetDate) {
            const targetDateTime = new Date(`${settings.targetDate}T${settings.targetTime || '12:00'}`);
            const now = new Date();
            const diff = targetDateTime - now;
            
            const valueEl = document.getElementById(`value-${habit}`);
            const breakdownEl = document.getElementById(`breakdown-${habit}`);
            
            // Check if we need to send notification
            const state = timerStates[habit] || {};
            
            if (diff <= 0) {
              // Expired - show pulsing 00:00
              if (valueEl) {
                valueEl.textContent = '00:00';
                valueEl.closest('.btn-habit')?.classList.add('pulsing');
              }
              if (breakdownEl) breakdownEl.textContent = '0d 0h 0m';
              
              // Send notification only once
              if (!state.notificationSent) {
                sendCountdownNotification(habit);
                timerStates[habit] = { ...state, notificationSent: true };
                saveTimerStates();
              }
            } else {
              // Still counting down - reset notification flag if it was set
              if (state.notificationSent) {
                timerStates[habit] = { ...state, notificationSent: false };
                saveTimerStates();
              }
              
              // Calculate remaining time
              const totalMinutes = Math.floor(diff / (1000 * 60));
              const totalSeconds = Math.floor(diff / 1000);
              const days = Math.floor(diff / (1000 * 60 * 60 * 24));
              const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
              const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
              const seconds = totalSeconds % 60;
              
              const btn = document.getElementById(`btn-${habit}`);
              if (btn) {
                // Thin line synced with current hour: full rotation every 60 minutes, counter-clockwise
                const nowClock = new Date();
                const minuteOfHour = nowClock.getMinutes() + nowClock.getSeconds() / 60;
                const angle = -90 - 360 * (minuteOfHour / 60);
                btn.style.setProperty('--progress-angle', `${angle}deg`);

                // Hourly flash once when a new hour boundary of the countdown is reached
                const minutesLeftInHour = totalMinutes % 60;
                const lastPing = btn.dataset.lastPingMinute ? parseInt(btn.dataset.lastPingMinute, 10) : null;

                if (minutesLeftInHour === 59 && lastPing !== totalMinutes) {
                  btn.classList.add('hour-ping');
                  setTimeout(() => btn.classList.remove('hour-ping'), 900);
                  btn.dataset.lastPingMinute = String(totalMinutes);
                } else if (minutesLeftInHour !== 59 && btn.dataset.lastPingMinute) {
                  delete btn.dataset.lastPingMinute;
                }
              }
              
              if (valueEl) valueEl.innerHTML = formatValueWithSuffix(totalMinutes, 'm');
              if (breakdownEl) breakdownEl.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
            }
          }
        }
      });

      // Ensure Math cells stay in sync with changing sources (timers/durations/countdown)
      scheduleMathRefresh();
    }

    // ===== RENDER =====
    function renderHabits() {
      const grid = document.getElementById('habitsGrid');
      grid.innerHTML = '';

      HABITS.forEach(habit => {
        const label = habitLabels[habit];
        const isActive = label?.trim();
        const typeRaw = habitTypes[habit] || CELL_TYPES.UNIT;
      const type = (typeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : typeRaw;
        const color = habitColors[habit] || '#ffffff';
        const state = durationStates[habit] || {};

        const btn = document.createElement('button');
        btn.className = 'btn-habit';
        btn.id = `btn-${habit}`;
        btn.dataset.type = type.toLowerCase();

        if (!isActive) {
          btn.classList.add('inactive');
          btn.style.cursor = 'default';
          btn.style.pointerEvents = 'none';
          grid.appendChild(btn);
          return;
        }

        let btnColor = color;
        if (!btnColor || btnColor === '#ffffff') {
          if (type === CELL_TYPES.DURATION_SEC) btnColor = '#35f2a3';
          else if (type === CELL_TYPES.DURATION_MIN) btnColor = '#ff8c42';
          else if (type === CELL_TYPES.DURATION_SEC_COUNT) btnColor = '#6b9dff';
        }
        btn.style.setProperty('--btn-color', btnColor);

        if (type === CELL_TYPES.COUNTER || type === CELL_TYPES.UNIT) {
          const value = getUnitDisplayValue(habit);
          const description = habitDescriptions[habit] || '';
          const lastUpdateLabel = formatCounterLastUpdate(habit);
          const breakdown = lastUpdateLabel || description;
          btn.innerHTML = `
            <span class="btn-label">${label}</span>
            <span class="btn-value" id="value-${habit}">${value}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${breakdown}</span>
          `;

        } else if (type === CELL_TYPES.VALUE) {
          const displayMain = getValueDisplay(habit);
          const description = habitDescriptions[habit] || '';
          btn.innerHTML = `
            <span class="btn-label">${label}</span>
            <span class="btn-value" id="value-${habit}">${displayMain}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${description}</span>
          `;
        } else if (type === CELL_TYPES.MATH) {
          const cfg = mathSettings[habit] || {};
          const val = computeMathValue(habit, new Set());
          const displayMain = formatMathDisplayValue(val, cfg);
          const breakdown = buildMathBreakdown(habit);
          btn.innerHTML = `
            <span class="btn-label">${label}</span>
            <span class="btn-value" id="value-${habit}">${displayMain}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${breakdown}</span>
          `;

        } else if (type === CELL_TYPES.MONEY_INCOME || type === CELL_TYPES.MONEY_BUDGET) {
          let weekObj = weekData[currentWeekKey];
          const cfg = moneySettings[habit] || {};
          const currency = cfg.currency || '€';
          const isIncome = type === CELL_TYPES.MONEY_INCOME;
          const description = habitDescriptions[habit] || '';

          let value = 0;

          // Ensure current week object exists so we can store values
          if (!weekObj || typeof weekObj !== 'object') {
            ensureWeekExists();
            weekObj = weekData[currentWeekKey];
          }

          if (weekObj && typeof weekObj === 'object') {
            if (weekObj[habit] == null) {
              if (!isIncome && cfg.startAmount != null) {
                value = cfg.startAmount;
                weekObj[habit] = value;
                saveWeekData();
              } else {
                value = 0;
              }
            } else {
              value = weekObj[habit] || 0;
            }
          } else {
            // Fallback, should not normally happen
            value = !isIncome && cfg.startAmount != null ? cfg.startAmount : 0;
          }

          const displayMain = formatValueWithSuffix(value, currency);
          const parts = [];
          parts.push(currency);
          if (description) parts.push(description);
          const breakdown = parts.join(' · ');

          btn.innerHTML = `
            <span class="btn-label">${label}</span>
            <span class="btn-value" id="value-${habit}">${displayMain}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${breakdown}</span>
          `;
        } else if (type === CELL_TYPES.TIMER) {
          const timerState = timerStates[habit] || {};
          const settings = timerSettings[habit] || { duration: 20, format: 'mm:ss' };
          const isRunning = timerState.isRunning;
          
          let displayValue = '00:00';
          if (isRunning && timerState.startTime && timerState.remaining) {
            const elapsed = Date.now() - timerState.startTime;
            const remaining = Math.max(0, timerState.remaining - elapsed);
            const seconds = Math.floor(remaining / 1000);
            
            if (settings.format === 'mm') {
              const minutes = Math.ceil(seconds / 60);
              displayValue = formatValueWithSuffix(minutes, 'm');
            } else {
              const m = Math.floor(seconds / 60);
              const s = seconds % 60;
              displayValue = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }
          } else {
            // Stopped state - show original duration
            if (settings.format === 'mm') {
              displayValue = formatValueWithSuffix(settings.duration, 'm');
            } else {
              const m = settings.duration;
              displayValue = `${String(m).padStart(2, '0')}:00`;
            }
          }

          if (settings.format !== 'mm') {
            displayValue = formatValueWithSuffix(displayValue, 's');
          }

          const breakdown = `timer cycles ${(timerState.iterations || 0) + 1}`;

          btn.innerHTML = `
            <span class="btn-label">${label}</span>
            <span class="btn-value" id="value-${habit}">${displayValue}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${breakdown}</span>
          `;
                    if (isRunning) {
            btn.classList.add('running');
            // Set initial progress
            if (timerState.startTime && timerState.remaining) {
              const elapsed = Date.now() - timerState.startTime;
              const remaining = Math.max(0, timerState.remaining - elapsed);
              const seconds = Math.floor(remaining / 1000);
              const secondsInMinute = seconds % 60;
              const progress = ((60 - secondsInMinute) / 60) * 100;
              btn.style.setProperty('--progress', progress);
            }
          }
        } else if (type === CELL_TYPES.COUNTDOWN) {
          const settings = timerSettings[habit] || {};
          let displayValue = '--:--';
          let breakdown = '-- -- --';
          
          if (settings.targetDate) {
            const targetDateTime = new Date(`${settings.targetDate}T${settings.targetTime || '12:00'}`);
            const now = new Date();
            const diff = targetDateTime - now;
            
            if (diff <= 0) {
              displayValue = '00:00';
              breakdown = '0d 0h 0m 0s';
              btn.classList.add('pulsing');
            } else {
              const totalMinutes = Math.floor(diff / (1000 * 60));
              const totalSeconds = Math.floor(diff / 1000);
              const days = Math.floor(diff / (1000 * 60 * 60 * 24));
              const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
              const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
              const seconds = totalSeconds % 60;

              displayValue = formatValueWithSuffix(totalMinutes, 'm');
              breakdown = `${days}d ${hours}h ${minutes}m ${seconds}s`;

              // Mark as running
              btn.classList.add('running');

              // Set initial orientation of the thin line based on current clock minute
              const nowClock = new Date();
              const minuteOfHour = nowClock.getMinutes() + nowClock.getSeconds() / 60;
              const angle = -90 - 360 * (minuteOfHour / 60);
              btn.style.setProperty('--progress-angle', `${angle}deg`);
            }
          }

          const labelText = label ? `until ${label}` : 'until';

          btn.innerHTML = `
            <span class="btn-label">${labelText}</span>
            <span class="btn-value" id="value-${habit}">${displayValue}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${breakdown}</span>
          `;
        } else {
          // Duration types (DURATION_SEC, DURATION_MIN, DURATION_SEC_COUNT)
          const isRunning = state.isRunning;
          const accumulated = state.accumulated || 0;
          let total = accumulated;
          let runtimeSeconds = 0;

          if (isRunning && state.startTime) {
            runtimeSeconds = Math.floor((Date.now() - state.startTime) / 1000);
            total += runtimeSeconds;
          }

          let displayValue;
          let breakdown;

          if (type === CELL_TYPES.DURATION_SEC) {
            // Show current session length as main value
            const sessionSeconds = (isRunning && state.startTime)
              ? runtimeSeconds
              : (state.lastSession || 0);

            const fmtSession = formatDurationSec(sessionSeconds);
            displayValue = formatValueWithSuffix(fmtSession.main, 's');

            // Breakdown shows total accumulated time
            const fmtTotal = formatDurationSec(total);
            breakdown = fmtTotal.breakdown;
          } else if (type === CELL_TYPES.DURATION_MIN) {
            const totalMin = Math.floor(total / 60);
            const fmt = formatDurationMin(totalMin, total);
            displayValue = formatValueWithSuffix(fmt.main, 'm');
            breakdown = fmt.breakdown;
          } else if (type === CELL_TYPES.DURATION_SEC_COUNT) {
            const fmt = formatDurationSec(total);
            displayValue = formatValueWithSuffix(total, 's');
            breakdown = fmt.breakdown;
          }

          const description = habitDescriptions[habit] || breakdown;

          btn.innerHTML = `
            <span class="btn-label">${label}</span>
            <span class="btn-value" id="value-${habit}">${displayValue}</span>
            <span class="btn-breakdown" id="breakdown-${habit}">${description}</span>
          `;

          if (isRunning) {
            btn.classList.add('running');
            // Set initial progress
            const secondsInMinute = total % 60;
            const progress = ((60 - secondsInMinute) / 60) * 100;
            btn.style.setProperty('--progress', progress);
          }
        }

        if (type === CELL_TYPES.MONEY_INCOME || type === CELL_TYPES.MONEY_BUDGET) {
          attachMoneyPressHandlers(btn, habit, type);
        } else if (type === CELL_TYPES.UNIT || type === CELL_TYPES.COUNTER) {
          attachUnitPressHandlers(btn, habit);
        } else {
          btn.addEventListener('click', () => handleHabitClick(habit));
        }
        grid.appendChild(btn);
      });

      const hasRunning = Object.values(durationStates).some(s => s.isRunning) ||
                         Object.values(timerStates).some(s => s.isRunning) ||
                         HABITS.some(h => habitTypes[h] === CELL_TYPES.COUNTDOWN);
      if (hasRunning) startGlobalInterval();
      else stopGlobalIntervalIfNeeded();

      updateStats();
      scheduleMathRefresh();
    }

    function updateCellDisplay(habit) {
      const typeRaw = habitTypes[habit] || CELL_TYPES.UNIT;
      const type = (typeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : typeRaw;
      if (type !== CELL_TYPES.COUNTER && type !== CELL_TYPES.UNIT) return;

      const valueEl = document.getElementById(`value-${habit}`);
      if (valueEl) {
        const value = getUnitDisplayValue(habit);
        valueEl.textContent = value;
      }

      const breakdownEl = document.getElementById(`breakdown-${habit}`);
      if (breakdownEl) {
        const description = habitDescriptions[habit] || '';
        const lastUpdateLabel = formatCounterLastUpdate(habit);
        breakdownEl.textContent = lastUpdateLabel || description;
      }      scheduleMathRefresh();


      updateStats();
    }


    function updateMoneyCellDisplay(habit, type) {
      const valueEl = document.getElementById(`value-${habit}`);
      const breakdownEl = document.getElementById(`breakdown-${habit}`);

      const cfg = moneySettings[habit] || {};
      const currency = cfg.currency || '€';
      const isIncome = type === CELL_TYPES.MONEY_INCOME;
      const description = habitDescriptions[habit] || '';
      const baseStep = cfg.step != null ? Math.abs(cfg.step) : 10;
      const step = baseStep === 0 ? 1 : baseStep;

      let rawValue = 0;
      const weekObj = weekData[currentWeekKey];

      if (weekObj && typeof weekObj === 'object') {
        const stored = weekObj[habit];

        if (stored == null) {
          if (!isIncome && cfg.startAmount != null) {
            const startAmount = Number(cfg.startAmount) || 0;
            rawValue = startAmount;
            weekObj[habit] = rawValue;
            saveWeekData();
          } else {
            rawValue = 0;
          }
        } else {
          rawValue = Number(stored) || 0;
        }
      }

      if (valueEl) {
        valueEl.innerHTML = formatValueWithSuffix(rawValue, currency);
      }

      if (breakdownEl) {
        const parts = [];
        if (step) {
          const sign = isIncome ? '+' : '−';
          if (currency) {
            parts.push(`${sign}${step} ${currency}`);
          } else {
            parts.push(`${sign}${step}`);
          }
        } else if (currency) {
          parts.push(currency);
        }
        if (description) parts.push(description);
        breakdownEl.textContent = parts.join(' · ');
      }

      updateStats();
    }
// ===== HEADER =====
    function updateHeader() {
      const weekEl = document.getElementById('weekDisplay');
      const dateEl = document.getElementById('dateDisplay');
      
      if (weekEl) weekEl.textContent = currentWeekKey;
      if (dateEl) {
        const range = getWeekDateRange(currentWeekKey);
        dateEl.textContent = formatDateRange(range.start, range.end);
      }
      
      updateHeaderTime();
    }

    function updateHeaderTime() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');

      const timeEl = document.getElementById('headerTime');
      if (timeEl) timeEl.textContent = `${hours}:${minutes}:${seconds}`;

      // Week progress (under dates on left)
      const dayOfWeek = now.getDay();
      const minutesInDay = now.getHours() * 60 + now.getMinutes();
      const dayIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const minutesInWeek = dayIndex * 24 * 60 + minutesInDay;
      const weekProgress = Math.round((minutesInWeek / (7 * 24 * 60)) * 100);

      const percentEl = document.getElementById('weekPercent');
      if (percentEl) percentEl.textContent = `${weekProgress}%`;

      // Day progress (0-100%)
      const dayProgress = Math.round((minutesInDay / (24 * 60)) * 100);

      // Day number (1-7)
      const dayNumber = dayIndex + 1;

      // Combined day info (7 96%)
      const dayInfoEl = document.getElementById('dayInfo');
      if (dayInfoEl) dayInfoEl.textContent = `DAY ${dayNumber} ${dayProgress}%`;

      // Day date (04 JAN SUNDAY in one line)
      const dayDateEl = document.getElementById('headerDayDate');
      if (dayDateEl) {
        const day = String(now.getDate()).padStart(2, '0');
        const monthName = now.toLocaleDateString('en-US', { month: 'short' }).toUpperCase();
        const dayNameFull = now.toLocaleDateString('en-US', { weekday: 'long' }).toUpperCase();
        dayDateEl.textContent = `${day} ${monthName} ${dayNameFull}`;
      }
    }

    // ===== STATS =====
    function updateStats() {
      const statsEl = document.getElementById('stats');
      const hasActive = HABITS.some(h => habitLabels[h]?.trim());

      if (!hasActive) {
        statsEl.innerHTML = '<div style="padding: 16px; text-align: center; opacity: 0.5; font-size: 12px;">No data yet</div>';
        return;
      }

      const allWeeks = Object.keys(weekData).sort().reverse().slice(0, 3);
      if (allWeeks.length === 0) {
        statsEl.innerHTML = '<div style="padding: 16px; text-align: center; opacity: 0.5; font-size: 12px;">No data yet</div>';
        return;
      }

      let html = '<table class="stats-table"><thead><tr><th>Week</th>';
      HABITS.forEach((h, idx) => {
        if (habitLabels[h]?.trim()) {
          html += `<th data-col="${idx}">${habitLabels[h]}</th>`;
        }
      });
      html += '</tr></thead><tbody>';

      allWeeks.forEach(week => {
        html += `<tr><td>${week}</td>`;
        HABITS.forEach((h, idx) => {
          if (habitLabels[h]?.trim()) {
            const weekObj = weekData[week];
            const value = (weekObj && typeof weekObj === 'object') ? (weekObj[h] || 0) : 0;
            const type = habitTypes[h] || CELL_TYPES.COUNTER;
            let display = value;
            
            if (type === CELL_TYPES.DURATION_SEC) {
              const m = Math.floor(value / 60);
              const s = value % 60;
              display = `${m}:${String(s).padStart(2, '0')}`;
            } else if (type === CELL_TYPES.DURATION_MIN) {
              display = `${value}m`;
            } else if (type === CELL_TYPES.DURATION_SEC_COUNT) {
              display = `${value}s`;
            }
            
            html += `<td data-col="${idx}">${display}</td>`;
          }
        });
        html += '</tr>';
      });

      // TOTAL row - sum all weeks for ALL types
      html += '<tr style="border-top: 1px solid rgba(255,255,255,0.15);"><td>TOTAL</td>';
      HABITS.forEach((h, idx) => {
        if (habitLabels[h]?.trim()) {
          const type = habitTypes[h] || CELL_TYPES.COUNTER;
          
          // Calculate total across ALL weeks (not just displayed 3)
          let total = 0;
          Object.keys(weekData).forEach(week => {
            const weekObj = weekData[week];
            if (weekObj && typeof weekObj === 'object') {
              total += (weekObj[h] || 0);
            }
          });
          
          let display = '-';
          if (total > 0) {
            if (type === CELL_TYPES.DURATION_SEC) {
              const m = Math.floor(total / 60);
              const s = total % 60;
              display = `${m}:${String(s).padStart(2, '0')}`;
            } else if (type === CELL_TYPES.DURATION_MIN) {
              display = `${total}m`;
            } else if (type === CELL_TYPES.DURATION_SEC_COUNT) {
              display = `${total}s`;
            } else {
              // COUNTER type
              display = total;
            }
          }
          
          html += `<td data-col="${idx}">${display}</td>`;
        }
      });
      html += '</tr>';

      html += '</tbody></table>';
      statsEl.innerHTML = html;
      
      attachTableHighlight();
    }

    // Table highlight on hover
    function attachTableHighlight() {
      const table = document.querySelector('.stats-table');
      if (!table) return;

      const cells = table.querySelectorAll('th, td');
      
      cells.forEach(cell => {
        cell.addEventListener('mouseenter', function() {
          const col = this.dataset.col;
          const row = this.closest('tr');

          // Dimmed row highlight
          if (row) {
            row.classList.add('row-highlight');
          }

          // Medium column highlight
          if (col !== undefined) {
            table.querySelectorAll(`th[data-col="${col}"], td[data-col="${col}"]`).forEach(c => {
              c.classList.add('col-highlight');
            });
          }

          // Bright cell highlight (only current cell)
          this.classList.add('cell-highlight');
        });

        cell.addEventListener('mouseleave', function() {
          // Remove all highlights
          table.querySelectorAll('.row-highlight').forEach(r => r.classList.remove('row-highlight'));
          table.querySelectorAll('.col-highlight').forEach(c => c.classList.remove('col-highlight'));
          table.querySelectorAll('.cell-highlight').forEach(c => c.classList.remove('cell-highlight'));
        });
      });
    }

    // ===== CONTROLS =====
    function toggleDecrease() {
      decreaseMode = !decreaseMode;
      document.getElementById('btnDecrease').classList.toggle('active', decreaseMode);
    }

    function copyCurrentWeek() {
      const data = weekData[currentWeekKey];
      const safeData = (data && typeof data === 'object') ? data : {};
      let text = `${currentWeekKey}\n`;
      HABITS.forEach(h => {
        const label = habitLabels[h];
        if (!label?.trim()) return;
        const value = safeData[h] || 0;
        const type = habitTypes[h] || CELL_TYPES.COUNTER;
        let display = value;
        if (type === CELL_TYPES.DURATION_SEC) {
          const m = Math.floor(value / 60);
          const s = value % 60;
          display = `${m}:${String(s).padStart(2, '0')}`;
        } else if (type === CELL_TYPES.DURATION_MIN) {
          display = `${value}m`;
        }
        text += `${label}: ${display}\n`;
      });
      navigator.clipboard?.writeText(text).then(() => alert('âœ“ Current week copied'));
    }

    function copyPreviousWeek() {
      const prevDate = new Date();
      prevDate.setDate(prevDate.getDate() - 7);
      const prevWeek = getWeekKey(prevDate);
      const data = weekData[prevWeek];
      const safeData = (data && typeof data === 'object') ? data : {};
      
      let text = `${prevWeek}\n`;
      HABITS.forEach(h => {
        const label = habitLabels[h];
        if (!label?.trim()) return;
        const value = safeData[h] || 0;
        const type = habitTypes[h] || CELL_TYPES.COUNTER;
        let display = value;
        if (type === CELL_TYPES.DURATION_SEC) {
          const m = Math.floor(value / 60);
          const s = value % 60;
          display = `${m}:${String(s).padStart(2, '0')}`;
        } else if (type === CELL_TYPES.DURATION_MIN) {
          display = `${value}m`;
        }
        text += `${label}: ${display}\n`;
      });
      navigator.clipboard?.writeText(text).then(() => alert('âœ“ Previous week copied'));
    }

    function exportData() {
      // Export current PIN state + settings
      const exportedTypes = { ...habitTypes };
      Object.keys(exportedTypes).forEach(k => {
        if (exportedTypes[k] === CELL_TYPES.COUNTER) exportedTypes[k] = CELL_TYPES.UNIT;
      });

      const exportObj = {
        version: '1.17',
        pin: currentPin,
        exportedAt: new Date().toISOString(),

        weekData,
        habitLabels,
        habitTypes: exportedTypes,
        habitColors,
        habitDescriptions,

        durationStates,
        timerSettings,
        moneySettings,

        unitSettings,
        valueFormats,
        mathSettings,

        themeSettings
      };

      const dataStr = JSON.stringify(exportObj, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `trckng_sstm_pin${currentPin}_export_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

function importData() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json,.json,.txt';
      input.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = () => {
          try {
            const imported = JSON.parse(reader.result);

            if (imported.weekData) weekData = imported.weekData;
            if (imported.habitLabels) habitLabels = { ...habitLabels, ...imported.habitLabels };

            if (imported.habitTypes) {
              const incoming = { ...imported.habitTypes };
              Object.keys(incoming).forEach(k => {
                if (incoming[k] === CELL_TYPES.COUNTER) incoming[k] = CELL_TYPES.UNIT;
              });
              habitTypes = { ...habitTypes, ...incoming };
            }

            if (imported.habitColors) habitColors = { ...habitColors, ...imported.habitColors };
            if (imported.habitDescriptions) habitDescriptions = { ...habitDescriptions, ...imported.habitDescriptions };

            if (imported.durationStates) durationStates = { ...durationStates, ...imported.durationStates };
            if (imported.timerSettings) timerSettings = { ...timerSettings, ...imported.timerSettings };
            if (imported.moneySettings) moneySettings = { ...moneySettings, ...imported.moneySettings };

            // Per-PIN settings (imported as-is into the current PIN)
            if (imported.unitSettings) unitSettings = imported.unitSettings;
            if (imported.valueFormats) valueFormats = imported.valueFormats;
            if (imported.mathSettings) mathSettings = imported.mathSettings;
            if (imported.themeSettings) themeSettings = imported.themeSettings;

            // Persist
            saveWeekData();
            saveLabels();
            saveTypes();
            saveColors();
            saveDescriptions();
            saveDurationStates();
            saveTimerSettings();
            saveMoneySettings();
            saveUnitSettings();
            saveValueFormats();
            saveMathSettings();
            saveThemeSettings();

            applyTheme();

            renderHabits();
            updateHeader();
            alert('Data imported successfully');
          } catch (err) {
            console.error(err);
            alert('Import failed: invalid file');
          }
        };
        reader.readAsText(file);
      });

      input.click();
    }



    function handleFileImport(e) {
      const file = e.target.files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const imported = JSON.parse(event.target.result);
          if (imported.weekData) Object.assign(weekData, imported.weekData);
          if (imported.habitLabels) Object.assign(habitLabels, imported.habitLabels);
          if (imported.habitTypes) Object.assign(habitTypes, imported.habitTypes);
          if (imported.habitColors) Object.assign(habitColors, imported.habitColors);
          if (imported.durationStates) Object.assign(durationStates, imported.durationStates);
          
          saveWeekData();
          saveLabels();
          saveTypes();
          saveColors();
          saveDurationStates();
          
          renderHabits();
          updateHeader();
          alert('Data imported successfully');
        } catch(err) {
          alert('Import failed: Invalid file format');
        }
      };
      reader.readAsText(file);
      
      // Reset input
      e.target.value = '';
    }

    function resetAll() {
      const pinNameRaw = (pinNames && pinNames[currentPin] != null) ? String(pinNames[currentPin]) : '';
      const pinName = pinNameRaw.trim() || getDefaultPinName(currentPin);
      if (!confirm(`RESET ${pinName}?
\nThis will clear all cells and data for this pin.`)) return;

      // Remove all per-pin data from storage
      const pin = currentPin;
      const suffix = `_pin${pin}`;

      const perPinKeys = [
        STORAGE_KEYS.DATA,
        STORAGE_KEYS.LABELS,
        STORAGE_KEYS.TYPES,
        STORAGE_KEYS.COLORS,
        STORAGE_KEYS.DESCRIPTIONS,
        STORAGE_KEYS.DURATION,
        STORAGE_KEYS.TIMER_SETTINGS,
        STORAGE_KEYS.TIMER_STATES,
        STORAGE_KEYS.COUNTER_LAST_UPDATE,
        STORAGE_KEYS.MONEY_SETTINGS
      ];

      perPinKeys.forEach(base => {
        localStorage.removeItem(`${base}${suffix}`);
      });

      // Prepare a blank layout for this pin
      const emptyLabels = {};
      const emptyDescriptions = {};
      const emptyTypes = {};
      const emptyColors = {};

      HABITS.forEach(habit => {
        emptyLabels[habit] = '';
        emptyDescriptions[habit] = '';
        emptyTypes[habit] = CELL_TYPES.COUNTER;
        emptyColors[habit] = '#ffffff';
      });

      localStorage.setItem(`${STORAGE_KEYS.LABELS}${suffix}`, JSON.stringify(emptyLabels));
      localStorage.setItem(`${STORAGE_KEYS.DESCRIPTIONS}${suffix}`, JSON.stringify(emptyDescriptions));
      localStorage.setItem(`${STORAGE_KEYS.TYPES}${suffix}`, JSON.stringify(emptyTypes));
      localStorage.setItem(`${STORAGE_KEYS.COLORS}${suffix}`, JSON.stringify(emptyColors));

      // Reload state for current pin
      loadWeekData();
      loadLabels();
      loadTypes();
      loadColors();
      loadDescriptions();
      loadDurationStates();
      loadTimerSettings();
      loadTimerStates();
      loadMoneySettings();
      loadUnitSettings();
      loadValueFormats();
      loadMathSettings();
      loadThemeSettings();
      applyTheme();
      loadCounterLastUpdate();

      currentWeekKey = getWeekKey();
      ensureWeekExists();
      renderHabits();
      updateHeader();
      applyPinNamesToUI();
    }

    // ===== PIN SWITCH =====
      function switchPin(pinNum) {
      if (globalInterval) {
        clearInterval(globalInterval);
        globalInterval = null;
      }

      currentPin = pinNum;
      document.querySelectorAll('.pin').forEach(p => p.classList.remove('active'));
      document.getElementById(`pin${pinNum}`).classList.add('active');
      
      // Update grid data-pin for pattern styling
      const grid = document.getElementById('habitsGrid');
      if (grid) grid.setAttribute('data-pin', pinNum);

      loadWeekData();
      loadLabels();
      loadTypes();
      loadColors();
      loadDescriptions();
      loadDurationStates();
      loadTimerSettings();
      loadTimerStates();
      loadMoneySettings();
      loadUnitSettings();
      loadValueFormats();
      loadMathSettings();
      loadThemeSettings();
      applyTheme();
      loadCounterLastUpdate();
      loadPinNames();
      currentWeekKey = getWeekKey();
      ensureWeekExists();
      renderHabits();
      updateHeader();
      applyPinNamesToUI();
    }

    // ===== EDIT MODALS =====
    function openEditModal() {
      const container = document.getElementById('editItemsContainer');
      container.innerHTML = '';

      HABITS.forEach((habit, index) => {
        const cellNum = String(index + 1).padStart(2, '0');
        const label = habitLabels[habit] || '';

        const item = document.createElement('button');
        item.className = 'edit-item';
        item.innerHTML = `
          <div class="edit-item-label">CELL ${cellNum}</div>
          <div class="edit-item-name">${label || "-"}</div>
        `;
        item.addEventListener('click', () => openCellEditModal(habit, index));
        container.appendChild(item);
      });

      document.getElementById('editModal').classList.add('visible');
    }

    function closeEditModal() {
      document.getElementById('editModal').classList.remove('visible');
    }


function openCellEditModal(habit, index) {
      editingHabit = habit;
      const cellNum = String(index + 1).padStart(2, '0');

      document.getElementById('cellEditLabel').textContent = `CELL ${cellNum}`;
      document.getElementById('cellEditInput').value = habitLabels[habit] || '';
      document.getElementById('cellEditColor').value = habitColors[habit] || '#ffffff';
      document.getElementById('cellEditDescription').value = habitDescriptions[habit] || '';

      const typeRaw = habitTypes[habit] || CELL_TYPES.UNIT;
      const type = (typeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : typeRaw;

      const moneyCfg = moneySettings[habit] || {};
      const stepField = document.getElementById('moneyStep');
      const currencyField = document.getElementById('moneyCurrency');
      const startField = document.getElementById('moneyStartAmount');
      if (stepField) stepField.value = moneyCfg.step != null ? moneyCfg.step : 10;
      if (currencyField) currencyField.value = moneyCfg.currency || '€';
      if (startField) startField.value = moneyCfg.startAmount != null ? moneyCfg.startAmount : '';
      document.querySelectorAll('#cellEditModal .type-btn[data-type]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });

      // Load timer settings if exists
      const settings = timerSettings[habit] || {
        duration: 20,
        format: 'mm:ss',
        sound: 'soft_chime',
        volume: 50,
        vibrate: true,
        message: '',
        targetDate: '',
        targetTime: '12:00'
      };

      document.getElementById('timerDuration').value = settings.duration || 20;
      document.getElementById('timerSound').value = settings.sound || 'soft_chime';
      document.getElementById('timerVolume').value = settings.volume || 50;
      document.getElementById('volumeValue').textContent = `${settings.volume || 50}%`;
      document.getElementById('timerMessage').value = settings.message || '';
      document.getElementById('countdownDate').value = settings.targetDate || '';
      document.getElementById('countdownTime').value = settings.targetTime || '12:00';
      document.getElementById('countdownSound').value = settings.sound || 'soft_chime';
      document.getElementById('countdownVolume').value = settings.volume || 50;
      document.getElementById('countdownVolumeValue').textContent = `${settings.volume || 50}%`;
      document.getElementById('countdownMessage').value = settings.message || '';

      // Set format buttons
      document.querySelectorAll('#cellEditModal [data-format]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.format === (settings.format || 'mm:ss'));
      });

      // Set vibrate buttons (timer)
      document.querySelectorAll('#cellEditModal [data-vibrate]').forEach(btn => {
        const isOn = settings.vibrate !== false;
        btn.classList.toggle('active', 
          (btn.dataset.vibrate === 'on' && isOn) || 
          (btn.dataset.vibrate === 'off' && !isOn)
        );
      });

      // Set vibrate buttons (countdown)
      document.querySelectorAll('#cellEditModal [data-vibrate-cd]').forEach(btn => {
        const isOn = settings.vibrate !== false;
        btn.classList.toggle('active', 
          (btn.dataset.vibrateCd === 'on' && isOn) || 
          (btn.dataset.vibrateCd === 'off' && !isOn)
        );
      });


      // Populate Unit fields
      const uCfg = unitSettings[habit] || { step: 1, total: false };
      const uStep = document.getElementById('unitStep');
      const uTotal = document.getElementById('unitTotal');
      if (uStep) uStep.value = (uCfg.step != null) ? uCfg.step : 1;
      if (uTotal) uTotal.checked = uCfg.total === true;

      // Populate Value fields
      const vFmt = valueFormats[habit] || 'raw';
      const vSel = document.getElementById('valueFormat');
      if (vSel) vSel.value = vFmt;

      // Populate Math selectors/options
      const buildOptions = (selectEl) => {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        HABITS.forEach((h, idx) => {
          const cellNum = String(idx + 1).padStart(2, '0');
          const name = habitLabels[h] ? habitLabels[h] : `CELL ${cellNum}`;
          const opt = document.createElement('option');
          opt.value = h;
          opt.textContent = name;
          selectEl.appendChild(opt);
        });
      };

      buildOptions(document.getElementById('mathSourceA'));
      buildOptions(document.getElementById('mathSourceB'));

      const mCfg = mathSettings[habit] || { a: HABITS[0], op: 'add', bMode: 'cell', b: HABITS[1], bNum: 1, formatFrom: 'a', tapCycles: false };
      const mA = document.getElementById('mathSourceA');
      const mOp = document.getElementById('mathOp');
      const mB = document.getElementById('mathSourceB');
      const mBN = document.getElementById('mathNumberB');
      const mFmt = document.getElementById('mathFormatFrom');
      const mTap = document.getElementById('mathTapCycles');

      if (mA) mA.value = mCfg.a || HABITS[0];
      if (mOp) mOp.value = mCfg.op || 'add';
      if (mB) mB.value = mCfg.b || HABITS[1] || HABITS[0];
      if (mBN) mBN.value = (mCfg.bNum != null) ? mCfg.bNum : 1;
      if (mFmt) mFmt.value = mCfg.formatFrom || 'a';
      if (mTap) mTap.checked = mCfg.tapCycles === true;

      // B mode buttons
      document.querySelectorAll('#cellEditModal .type-btn[data-math-bmode]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mathBmode === (mCfg.bMode || 'cell'));
      });

      // Toggle B input UI
      const bCellWrap = document.getElementById('mathBCellWrap');
      const bNumWrap = document.getElementById('mathBNumberWrap');
      const bm = mCfg.bMode || 'cell';
      if (bCellWrap) bCellWrap.style.display = (bm === 'cell') ? 'block' : 'none';
      if (bNumWrap) bNumWrap.style.display = (bm === 'number') ? 'block' : 'none';


      // Show/hide appropriate fields
      updateTimerFieldsVisibility(type);

      document.getElementById('cellEditModal').classList.add('visible');
      setTimeout(() => document.getElementById('cellEditInput').focus(), 100);
    }

    function updateTimerFieldsVisibility(type) {
      const timerFields = document.getElementById('timerSettingsFields');
      const countdownFields = document.getElementById('countdownSettingsFields');
      const moneyFields = document.getElementById('moneySettingsFields');
      const unitFields = document.getElementById('unitSettingsFields');
      const valueFields = document.getElementById('valueSettingsFields');
      const mathFields = document.getElementById('mathSettingsFields');
      const descField = document.getElementById('descriptionField');
      const moneyStartField = document.getElementById('moneyStartAmountField');

      const t = typeof type === 'string' ? type : (type || '');

      const show = (el, on) => { if (el) el.style.display = on ? 'block' : 'none'; };

      show(timerFields, t === CELL_TYPES.TIMER);
      show(countdownFields, t === CELL_TYPES.COUNTDOWN);
      show(moneyFields, t === CELL_TYPES.MONEY_INCOME || t === CELL_TYPES.MONEY_BUDGET);
      show(unitFields, t === CELL_TYPES.UNIT || t === CELL_TYPES.COUNTER);
      show(valueFields, t === CELL_TYPES.VALUE);
      show(mathFields, t === CELL_TYPES.MATH);

      // Description is useful for most types, but keep it hidden for pure math by default
      show(descField, t !== CELL_TYPES.MATH);

      // Budget start amount only for Budget
      show(moneyStartField, t === CELL_TYPES.MONEY_BUDGET);
    }
    
    function closeCellEditModal() {
      document.getElementById('cellEditModal').classList.remove('visible');
      editingHabit = null;
    }
function saveCellEdit() {
      if (!editingHabit) return;

      const newLabel = document.getElementById('cellEditInput').value.trim();
      const newColor = document.getElementById('cellEditColor').value;
      const newDescription = document.getElementById('cellEditDescription').value.trim();
      const activeTypeBtn = document.querySelector('#cellEditModal .type-btn.active[data-type]');
      const newType = (activeTypeBtn && activeTypeBtn.dataset.type) ? activeTypeBtn.dataset.type : CELL_TYPES.UNIT;
      const normalizedType = (newType === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : newType;


      const oldTypeRaw = habitTypes[editingHabit];
      const oldType = (oldTypeRaw === CELL_TYPES.COUNTER) ? CELL_TYPES.UNIT : oldTypeRaw;
      const wasActive = habitLabels[editingHabit] && habitLabels[editingHabit].trim();
      const typeChanged = oldType !== normalizedType;

      const oldIsDuration =
        oldType === CELL_TYPES.DURATION_SEC ||
        oldType === CELL_TYPES.DURATION_MIN ||
        oldType === CELL_TYPES.DURATION_SEC_COUNT;

      const newIsDuration =
        normalizedType === CELL_TYPES.DURATION_SEC ||
        normalizedType === CELL_TYPES.DURATION_MIN ||
        normalizedType === CELL_TYPES.DURATION_SEC_COUNT;

      const oldIsTimer =
        oldType === CELL_TYPES.TIMER ||
        oldType === CELL_TYPES.COUNTDOWN;

      const newIsTimer =
        normalizedType === CELL_TYPES.TIMER ||
        normalizedType === CELL_TYPES.COUNTDOWN;

      if (wasActive && !newLabel) {
        // Deactivating cell - wipe all stored values for this habit across weeks
        // If you ever want to change this behavior, adjust deletion logic here
        Object.keys(weekData).forEach(week => {
          if (weekData[week] && typeof weekData[week] === 'object') {
            delete weekData[week][editingHabit];
          }
        });
        delete durationStates[editingHabit];
        delete timerStates[editingHabit];
        delete timerSettings[editingHabit];
        delete moneySettings[editingHabit];
      } else if (typeChanged) {
        // Type changed
        if (oldIsDuration && newIsDuration) {
          // Duration to duration - convert values
          Object.keys(weekData).forEach(week => {
            if (weekData[week] && typeof weekData[week] === 'object') {
              const oldValue = weekData[week][editingHabit] || 0;
              let seconds = oldValue;
              if (oldType === CELL_TYPES.DURATION_MIN) {
                seconds = oldValue * 60;
              }
              if (normalizedType === CELL_TYPES.DURATION_MIN) {
                weekData[week][editingHabit] = Math.floor(seconds / 60);
              } else {
                weekData[week][editingHabit] = seconds;
              }
            }
          });
        } else {
          // Any other type change - reset
          if (normalizedType === CELL_TYPES.MONEY_INCOME || normalizedType === CELL_TYPES.MONEY_BUDGET) {
            // For money cells, start "empty" so budget can apply start amount on first display
            Object.keys(weekData).forEach(week => {
              if (weekData[week] && typeof weekData[week] === 'object') {
                delete weekData[week][editingHabit];
              }
            });
          } else {
            Object.keys(weekData).forEach(week => {
              if (weekData[week] && typeof weekData[week] === 'object') {
                weekData[week][editingHabit] = 0;
              }
            });
          }
          delete durationStates[editingHabit];
          delete timerStates[editingHabit];
          delete timerSettings[editingHabit];
          delete moneySettings[editingHabit];
        }
      }

      // Save timer/countdown settings
      if (normalizedType === CELL_TYPES.TIMER) {
        const formatBtn = document.querySelector('[data-format].active');
        const vibrateBtn = document.querySelector('[data-vibrate].active');
        timerSettings[editingHabit] = {
          duration: parseInt(document.getElementById('timerDuration').value, 10) || 20,
          format: formatBtn ? formatBtn.dataset.format : 'mm:ss',
          sound: document.getElementById('timerSound').value || 'soft_chime',
          volume: parseInt(document.getElementById('timerVolume').value, 10) || 50,
          vibrate: vibrateBtn ? vibrateBtn.dataset.vibrate === 'on' : true,
          message: document.getElementById('timerMessage').value.trim()
        };
      } else if (normalizedType === CELL_TYPES.COUNTDOWN) {
        const vibrateCdBtn = document.querySelector('[data-vibrate-cd].active');
        timerSettings[editingHabit] = {
          targetDate: document.getElementById('countdownDate').value,
          targetTime: document.getElementById('countdownTime').value || '12:00',
          sound: document.getElementById('countdownSound').value || 'soft_chime',
          volume: parseInt(document.getElementById('countdownVolume').value, 10) || 50,
          vibrate: vibrateCdBtn ? vibrateCdBtn.dataset.vibrateCd === 'on' : true,
          message: document.getElementById('countdownMessage').value.trim()
        };
      } else {
        delete timerSettings[editingHabit];
      }

      // Save money settings
      if (normalizedType === CELL_TYPES.MONEY_INCOME || normalizedType === CELL_TYPES.MONEY_BUDGET) {
        const stepInput = parseFloat(document.getElementById('moneyStep').value);
        const currencyInput = document.getElementById('moneyCurrency').value.trim();
        const startInputRaw = document.getElementById('moneyStartAmount').value;
        const startInput = startInputRaw === '' ? NaN : parseFloat(startInputRaw);

        moneySettings[editingHabit] = {
          step: !isNaN(stepInput) && stepInput !== 0 ? stepInput : 10,
          currency: currencyInput || '€'
        };

        if (!isNaN(startInput)) {
          moneySettings[editingHabit].startAmount = startInput;
        } else {
          delete moneySettings[editingHabit].startAmount;
        }
      } else {
        delete moneySettings[editingHabit];
      }

      habitLabels[editingHabit] = newLabel;
      habitColors[editingHabit] = newColor;
      habitTypes[editingHabit] = normalizedType;
      habitDescriptions[editingHabit] = newDescription;

      saveLabels();
      saveColors();
      saveTypes();
      saveDescriptions();
      saveTimerSettings();
      saveMoneySettings();
      saveWeekData();
      saveDurationStates();
      saveTimerStates();
      saveCounterLastUpdate();

      // Persist settings for new types
      if (normalizedType === CELL_TYPES.UNIT) {
        const step = Number(document.getElementById('unitStep')?.value);
        unitSettings[editingHabit] = {
          step: (Number.isFinite(step) && step > 0) ? Math.floor(step) : 1,
          total: Boolean(document.getElementById('unitTotal')?.checked)
        };
        saveUnitSettings();
      } else {
        delete unitSettings[editingHabit];
        saveUnitSettings();
      }

      if (normalizedType === CELL_TYPES.VALUE) {
        const fmt = document.getElementById('valueFormat')?.value || 'raw';
        valueFormats[editingHabit] = fmt;
        saveValueFormats();
      } else {
        delete valueFormats[editingHabit];
        saveValueFormats();
      }

      if (normalizedType === CELL_TYPES.MATH) {
        const a = document.getElementById('mathSourceA')?.value || '';
        const op = document.getElementById('mathOp')?.value || 'add';
        const bMode = document.querySelector('#cellEditModal .type-btn.active[data-math-bmode]')?.dataset.mathBmode || 'cell';
        const b = document.getElementById('mathSourceB')?.value || '';
        const bNum = Number(document.getElementById('mathNumberB')?.value);
        const formatFrom = document.getElementById('mathFormatFrom')?.value || 'a';
        const tapCycles = Boolean(document.getElementById('mathTapCycles')?.checked);

        mathSettings[editingHabit] = {
          a,
          op,
          bMode,
          b,
          bNum: Number.isFinite(bNum) ? bNum : 1,
          formatFrom,
          tapCycles
        };

        if (wouldCreateMathCycle(editingHabit)) {
          // Revert and warn, keep modal open
          delete mathSettings[editingHabit];
          document.getElementById('mathStatusLine').textContent = 'Cycle detected. Settings not saved.';
          return;
        } else {
          document.getElementById('mathStatusLine').textContent = '';
          saveMathSettings();
        }
      } else {
        delete mathSettings[editingHabit];
        saveMathSettings();
      }


      closeCellEditModal();
      openEditModal();
      renderHabits();
    }


function openInfoModal() {
      localStorage.setItem(STORAGE_KEYS.SEEN_INFO, 'true');
      document.getElementById('btnInfo').classList.remove('pulse');
      document.getElementById('infoModal').classList.add('visible');
    }

    function closeInfoModal() {
      document.getElementById('infoModal').classList.remove('visible');
    }

    function syncThemeModalInputs() {
      const t = themeSettings || defaultThemeSettings();
      document.getElementById('themeBg').value = t.bg || '#000000';
      document.getElementById('themeText').value = t.text || '#ffffff';
      document.getElementById('themeBtnBg').value = t.btnBg || '#000000';
      document.getElementById('themeBtnText').value = t.btnText || '#ffffff';

      // If stored as rgba, fall back to white in picker
      document.getElementById('themeStrokeSoft').value = (typeof t.strokeSoft === 'string' && t.strokeSoft.startsWith('#')) ? t.strokeSoft : '#ffffff';
      document.getElementById('themeStrokeStrong').value = (typeof t.strokeStrong === 'string' && t.strokeStrong.startsWith('#')) ? t.strokeStrong : '#ffffff';
    }

    function openThemeModal() {
      syncThemeModalInputs();
      document.getElementById('themeModal').classList.add('visible');
    }

    function closeThemeModal() {
      document.getElementById('themeModal').classList.remove('visible');
    }


    // Simple helper to toggle help panels
    function togglePanelVisibility(id) {
      const el = document.getElementById(id);
      if (!el) return;
      el.classList.toggle('visible');
    }

// ===== INIT =====
    function updateCellDiagonalAngle() {
      const sampleCell = document.querySelector('.buttons-grid .btn-habit');
      if (!sampleCell) return;
      const rect = sampleCell.getBoundingClientRect();
      if (!rect.width || !rect.height) return;
      const angleRad = Math.atan(rect.height / rect.width);
      const angleDeg = angleRad * 180 / Math.PI;
      document.documentElement.style.setProperty('--cell-diagonal-angle', angleDeg + 'deg');
    }

    function init() {
      loadWeekData();
      loadLabels();
      loadTypes();
      loadColors();
      loadDescriptions();
      loadDurationStates();
      loadTimerSettings();
      loadTimerStates();
      loadMoneySettings();
      loadUnitSettings();
      loadValueFormats();
      loadMathSettings();
      loadThemeSettings();
      applyTheme();
      loadCounterLastUpdate();
      loadPinNames();
      
      // Check if week changed - reset duration states for new week
      const lastWeekKey = localStorage.getItem('trckng_last_week_key');
      if (lastWeekKey && lastWeekKey !== currentWeekKey) {
        console.log('New week detected! Resetting duration states.');
        durationStates = {};
        saveDurationStates();
      }
      localStorage.setItem('trckng_last_week_key', currentWeekKey);
      
      ensureWeekExists();

      renderHabits();
      updateHeader();

      if (!localStorage.getItem(STORAGE_KEYS.SEEN_INFO)) {
        document.getElementById('btnInfo').classList.add('pulse');
      }

      // Update clock every second (fixes lag issue)
      clockInterval = setInterval(updateHeaderTime, 1000);

      document.querySelectorAll('.pin').forEach(btn => {
        btn.addEventListener('click', () => switchPin(parseInt(btn.dataset.pin)));
      });

      document.getElementById('btnDecrease').addEventListener('click', toggleDecrease);
      document.getElementById('btnEdit').addEventListener('click', openEditModal);
      const pinRenameBtn = document.getElementById('btnEditPinName');
      if (pinRenameBtn) {
        pinRenameBtn.addEventListener('click', () => {
          const raw = (pinNames && pinNames[currentPin] != null) ? String(pinNames[currentPin]) : '';
          const currentName = raw.trim() || getDefaultPinName(currentPin);
          const newName = prompt('Pin name', currentName);
          if (newName === null) return;
          const trimmed = newName.trim();
          if (trimmed) {
            pinNames[currentPin] = trimmed;
          } else {
            delete pinNames[currentPin];
          }
          savePinNames();
          applyPinNamesToUI();
        });
      }
      const editHelpBtn = document.getElementById('btnEditHelp');
      if (editHelpBtn) {
        editHelpBtn.addEventListener('click', () => togglePanelVisibility('editHelpPanel'));
      }
      const cellEditHelpBtn = document.getElementById('btnCellEditHelp');
      if (cellEditHelpBtn) {
        cellEditHelpBtn.addEventListener('click', () => togglePanelVisibility('cellEditHelpPanel'));
      }
      document.getElementById('btnCopy').addEventListener('click', copyCurrentWeek);
      document.getElementById('btnCopyPrev').addEventListener('click', copyPreviousWeek);
      document.getElementById('btnExport').addEventListener('click', exportData);
      document.getElementById('btnImport').addEventListener('click', importData);
      document.getElementById('btnReset').addEventListener('click', resetAll);
      document.getElementById('btnInfo').addEventListener('click', openInfoModal);
    document.getElementById('btnTheme').addEventListener('click', openThemeModal);

    document.getElementById('valueModalCancel').addEventListener('click', closeValueModal);
    document.getElementById('valueModalClear').addEventListener('click', () => {
      document.getElementById('valueModalInput').value = 0;
    });
    document.getElementById('valueModalSave').addEventListener('click', () => {
      if (!editingValueHabit) return closeValueModal();
      ensureWeekExists();
      const v = Number(document.getElementById('valueModalInput').value);
      weekData[currentWeekKey][editingValueHabit] = Number.isFinite(v) ? v : 0;
      saveWeekData();
      renderHabits();
      closeValueModal();
    });

    document.getElementById('themeCancel').addEventListener('click', closeThemeModal);
    document.getElementById('themeReset').addEventListener('click', () => {
      themeSettings = defaultThemeSettings();
      syncThemeModalInputs();
      applyTheme();
      saveThemeSettings();
    });
    document.getElementById('themeSave').addEventListener('click', () => {
      themeSettings = {
        bg: document.getElementById('themeBg').value,
        text: document.getElementById('themeText').value,
        btnBg: document.getElementById('themeBtnBg').value,
        btnText: document.getElementById('themeBtnText').value,
        strokeSoft: document.getElementById('themeStrokeSoft').value,
        strokeStrong: document.getElementById('themeStrokeStrong').value
      };
      applyTheme();
      saveThemeSettings();
      closeThemeModal();
    });
      document.getElementById('btnInfoClose').addEventListener('click', closeInfoModal);

      document.getElementById('editModalClose').addEventListener('click', closeEditModal);
      document.getElementById('cellEditCancel').addEventListener('click', closeCellEditModal);
      document.getElementById('cellEditSave').addEventListener('click', saveCellEdit);

      document.querySelectorAll('#cellEditModal .type-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            // Type buttons
            if (btn.dataset.type) {
              document.querySelectorAll('#cellEditModal .type-btn[data-type]').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              updateTimerFieldsVisibility(btn.dataset.type);
              return;
            }
    
            // Format buttons (Duration)
            if (btn.dataset.format) {
              document.querySelectorAll('#cellEditModal [data-format]').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              return;
            }
    
            // Vibrate (Timer)
            if (btn.dataset.vibrate) {
              document.querySelectorAll('#cellEditModal [data-vibrate]').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              return;
            }
    
            // Vibrate (Countdown)
            if (btn.dataset.vibrateCd) {
              document.querySelectorAll('#cellEditModal [data-vibrate-cd]').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              return;
            }
    
            // Math B mode
            if (btn.dataset.mathBmode) {
              document.querySelectorAll('#cellEditModal .type-btn[data-math-bmode]').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              const bm = btn.dataset.mathBmode;
              const bCellWrap = document.getElementById('mathBCellWrap');
              const bNumWrap = document.getElementById('mathBNumberWrap');
              if (bCellWrap) bCellWrap.style.display = (bm === 'cell') ? 'block' : 'none';
              if (bNumWrap) bNumWrap.style.display = (bm === 'number') ? 'block' : 'none';
              return;
            }
          });
        });

      // Volume sliders
      document.getElementById('timerVolume').addEventListener('input', (e) => {
        document.getElementById('volumeValue').textContent = `${e.target.value}%`;
      });
      
      document.getElementById('countdownVolume').addEventListener('input', (e) => {
        document.getElementById('countdownVolumeValue').textContent = `${e.target.value}%`;
      });

      
      // Sound preview buttons
      const timerSoundSelect = document.getElementById('timerSound');
      const timerSoundTestBtn = document.getElementById('timerSoundTest');
      if (timerSoundSelect && timerSoundTestBtn) {
        timerSoundTestBtn.addEventListener('click', () => {
          const volume = parseInt(document.getElementById('timerVolume').value) || 50;
          const sound = timerSoundSelect.value || 'soft_chime';
          playNotificationSound(sound, volume);
        });
      }

      const countdownSoundSelect = document.getElementById('countdownSound');
      const countdownSoundTestBtn = document.getElementById('countdownSoundTest');
      if (countdownSoundSelect && countdownSoundTestBtn) {
        countdownSoundTestBtn.addEventListener('click', () => {
          const volume = parseInt(document.getElementById('countdownVolume').value) || 50;
          const sound = countdownSoundSelect.value || 'soft_chime';
          playNotificationSound(sound, volume);
        });
      }

document.getElementById('fileInput').addEventListener('change', handleFileImport);

      document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.classList.remove('visible');
        });
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          document.querySelectorAll('.modal.visible').forEach(m => m.classList.remove('visible'));
        }
      });

      applyPinNamesToUI();
      updateCellDiagonalAngle();
      window.addEventListener('resize', updateCellDiagonalAngle);

    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
